<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="codeva-XHCX41TH3N">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.planejun.cn","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1、保护模式简介CPU分有：实模式、保护模式、虚拟8086模式，大多数操作系统都运行在保护模式下。 保护模式主要是用来保护寄存器、数据结构、指令，实际上也就是保护寄存器，因为cpu的数据都存放在寄存器中。 保护模式的特点：段和页。  实模式：16位系统DOS，访问的都是物理地址，不安全。 保护模式：将物理地址隔阂后，使用一种线性的虚拟地址来访问，相对实模式来说比较安全。并用段和页的特点来维护虚拟地">
<meta property="og:type" content="article">
<meta property="og:title" content="x86保护模式">
<meta property="og:url" content="https://blog.planejun.cn/2022/10/10/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="PlaneJun&#39;Blog">
<meta property="og:description" content="1、保护模式简介CPU分有：实模式、保护模式、虚拟8086模式，大多数操作系统都运行在保护模式下。 保护模式主要是用来保护寄存器、数据结构、指令，实际上也就是保护寄存器，因为cpu的数据都存放在寄存器中。 保护模式的特点：段和页。  实模式：16位系统DOS，访问的都是物理地址，不安全。 保护模式：将物理地址隔阂后，使用一种线性的虚拟地址来访问，相对实模式来说比较安全。并用段和页的特点来维护虚拟地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_1.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_2.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_3.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_1.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_2.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_3.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_4.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_5.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_17.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_6.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_7.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_8.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_9.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_10.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_11.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_12.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_13.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_14.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_15.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_16.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_4.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_5.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_6.jpeg">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028142955249.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028142922784.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028171858280.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028172347806.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028172310947.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028172807035.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028184231219.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028191429965.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028191518915.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028194713225.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028200858575.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028200959253.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028201116857.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028201232089.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028202041627.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028202349714.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028202522357.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028203140417.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028203401508.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029154208996.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029154542770.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029154614726.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029155527981.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029155648779.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029161147825.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029161254790.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029162514739.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029162813573.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029162956265.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030123121116.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030122710511.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030122744380.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030122813632.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029164026531.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030124607785.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030124837901.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030124917851.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031142520796.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031143307127.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031143448888.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031143703152.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031144646917.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031144418041.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031145236635.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031150810537.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031150905333.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031151543103.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031152749546.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031154025086.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155438210.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155555167.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031152833171.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031154909931.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155105966.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155314591.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155342795.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101213529497.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101204659991.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101213120017.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101213211284.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101214425488.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101220518905.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101221127844.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101221219040.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102221050831.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102221555765.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102221412169.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102222814542.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102222014984.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102223147321.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102223314124.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102223456812.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102224139240.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102232909532.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102233427425.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102234021660.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102234105221.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215644361.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215710523.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215741029.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215939831.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103220203339.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103220713373.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103220733841.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103221310918.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103222041844.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103224204506.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103224240906.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103225309298.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103230007148.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103232902036.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412100130216.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412101456731.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412102152104.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412102229823.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412102406660.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412104327299.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412104536369.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412104550249.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412105907184.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412110130511.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412110222330.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413094816983.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413104410108.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413105519620.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413105722619.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413105815776.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413113703728.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413113807329.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519114908954.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519151435985.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519151441972.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519121927102.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519121953464.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519122028569.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521012611661.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524231314576.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524233000843.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524233239514.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524233420397.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/QQ%E5%9B%BE%E7%89%8720230519152651.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519154133640.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519160245941.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519161304372.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519161452057.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519164716376.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521142724659.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521143220842.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521143513360.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521144553724.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521143220842.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521160606649.png">
<meta property="og:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521160642513.png">
<meta property="article:published_time" content="2022-10-10T03:25:00.000Z">
<meta property="article:modified_time" content="2023-04-12T15:04:00.000Z">
<meta property="article:author" content="PlaneJun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.planejun.cn/images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled.jpeg">


<link rel="canonical" href="https://blog.planejun.cn/2022/10/10/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.planejun.cn/2022/10/10/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","path":"2022/10/10/x86保护模式/","title":"x86保护模式"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>x86保护模式 | PlaneJun'Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PlaneJun'Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我是从未来来的！现在学已经来不及了，放开玩吧！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-github"><a href="https://www.github.com/PlaneJun" rel="section" target="_blank">GitHub</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E3%80%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">1、保护模式简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%E3%80%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">2、段寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 段选择子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 段描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#G%E4%BD%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">G位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-x2F-B%E4%BD%8D"><span class="nav-number">2.2.2.</span> <span class="nav-text">D&#x2F;B位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P%E4%BD%8D"><span class="nav-number">2.2.3.</span> <span class="nav-text">P位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DPL%E4%BD%8D"><span class="nav-number">2.2.4.</span> <span class="nav-text">DPL位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#S%E4%BD%8D"><span class="nav-number">2.2.5.</span> <span class="nav-text">S位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type%E4%BD%8D"><span class="nav-number">2.2.6.</span> <span class="nav-text">Type位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%88%E5%AF%B9E%E4%BD%8D%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E9%AA%8C%EF%BC%9A"><span class="nav-number">2.2.7.</span> <span class="nav-text">针对E位的理解与实验：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9Ads"><span class="nav-number">2.2.7.1.</span> <span class="nav-text">实验一：ds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9Ass"><span class="nav-number">2.2.7.2.</span> <span class="nav-text">实验二：ss</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%81%E6%98%8E"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 段寄存器证明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%9D%83%E9%99%90"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 段寄存器权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%9A"><span class="nav-number">2.4.1.</span> <span class="nav-text">数据段：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9ACPL-x3D-3-RPL-x3D-3-DPL-x3D-3"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">实验一：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ACPL-x3D-3-RPL-x3D-0-DPL-x3D-3"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">实验二：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9ACPL-x3D-3-RPL-x3D-3-DPL-x3D-0"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">实验三：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9ACPL-x3D-3-RPL-x3D-0-DPL-x3D-0"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">实验四：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%EF%BC%88%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC-%E4%B8%8D%E6%8F%90%E6%9D%83%EF%BC%89%EF%BC%9A"><span class="nav-number">2.4.2.</span> <span class="nav-text">代码段（跨段跳转-不提权）：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E8%B7%B3%E8%BD%AC%E4%B8%8E%E7%9F%AD%E8%B7%B3%E8%BD%AC"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">长跳转与短跳转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9ACPL-x3D-3-RPL-x3D-3-DPL-x3D-3-1"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">实验一：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ACPL-x3D-3-RPL-x3D-0-DPL-x3D-3-1"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">实验二：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9ACPL-x3D-3-RPL-x3D-3-DPL-x3D-0-1"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">实验三：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9ACPL-x3D-3-RPL-x3D-0-DPL-x3D-0-1"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">实验四：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9ACPL-x3D-3-RPL-x3D-3-DPL-x3D-3-%EF%BC%88retf%EF%BC%89"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">实验五：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3 （retf）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3%E3%80%81%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-number">3.</span> <span class="nav-text">3、调用门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%8F%90%E6%9D%83R3%E8%BF%9B%E5%85%A5R0%E7%8E%AF"><span class="nav-number">3.1.</span> <span class="nav-text">实验一：提权R3进入R0环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E8%B0%83%E7%94%A80%E7%8E%AF%E5%87%BD%E6%95%B0-DbgPrint"><span class="nav-number">3.2.</span> <span class="nav-text">实验二：调用0环函数(DbgPrint)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4%E3%80%81%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="nav-number">4.</span> <span class="nav-text">4、中断门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%9E%84%E9%80%A0%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="nav-number">4.1.</span> <span class="nav-text">实验一：构造中断门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E5%A0%86%E6%A0%88%E5%BD%B1%E5%93%8D"><span class="nav-number">4.2.</span> <span class="nav-text">实验二：堆栈影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9AIF"><span class="nav-number">4.3.</span> <span class="nav-text">实验三：IF</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5%E3%80%81%E9%99%B7%E9%98%B1%E9%97%A8"><span class="nav-number">5.</span> <span class="nav-text">5、陷阱门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9AVM%E3%80%81TF%E3%80%81IF%E3%80%81NT"><span class="nav-number">5.1.</span> <span class="nav-text">实验一：VM、TF、IF、NT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E3%80%81%E4%BB%BB%E5%8A%A1%E6%AE%B5"><span class="nav-number">6.</span> <span class="nav-text">6、任务段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%9E%84%E9%80%A0%E4%BB%BB%E5%8A%A1%E6%AE%B5"><span class="nav-number">6.1.</span> <span class="nav-text">实验一：构造任务段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E5%88%86%E6%9E%90%E8%93%9D%E5%B1%8F%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.2.</span> <span class="nav-text">实验二：分析蓝屏原因</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7%E3%80%81%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="nav-number">7.</span> <span class="nav-text">7、任务门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-%E5%8F%8C%E9%87%8D%E5%BC%82%E5%B8%B8"><span class="nav-number">7.1.</span> <span class="nav-text">Windows-双重异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%9E%84%E9%80%A0%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="nav-number">7.2.</span> <span class="nav-text">实验一：构造任务门</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E3%80%81101012%E5%88%86%E9%A1%B5"><span class="nav-number">8.</span> <span class="nav-text">8、101012分页</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE101012%E5%88%86%E9%A1%B5"><span class="nav-number">8.1.</span> <span class="nav-text">设置101012分页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%BD%AC%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">8.2.</span> <span class="nav-text">实验一：线性地址转物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E5%B0%86%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">8.3.</span> <span class="nav-text">实验二：将同一个线性地址转成物理地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9%E3%80%81%E6%8E%A2%E7%B4%A20%E5%9C%B0%E5%9D%80"><span class="nav-number">9.</span> <span class="nav-text">9、探索0地址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A0%E5%9C%B0%E5%9D%80%E6%8C%82%E7%89%A9%E7%90%86%E9%A1%B5"><span class="nav-number">9.1.</span> <span class="nav-text">实验一：0地址挂物理页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E5%AF%B9%E9%BD%90"><span class="nav-number">9.2.</span> <span class="nav-text">实验二：页内偏移对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A0%E5%9C%B0%E5%9D%80%E5%AE%9E%E7%8E%B0shellcode%E6%89%A7%E8%A1%8C"><span class="nav-number">9.3.</span> <span class="nav-text">实验三：0地址实现shellcode执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10%E3%80%81%E9%A1%B5%E5%B1%9E%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">10、页属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9AR-x2F-W%E4%BD%8D"><span class="nav-number">10.1.</span> <span class="nav-text">实验一：R&#x2F;W位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9AU-x2F-W%E4%BD%8D"><span class="nav-number">10.2.</span> <span class="nav-text">实验二：U&#x2F;W位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11%E3%80%81%E9%A1%B5%E5%9F%BA%E5%9D%80"><span class="nav-number">11.</span> <span class="nav-text">11、页基址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E9%AA%8C%E8%AF%81%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80"><span class="nav-number">11.1.</span> <span class="nav-text">实验一：验证页表基址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%ABCR3"><span class="nav-number">11.2.</span> <span class="nav-text">实验二：页表基址获取自身CR3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E9%80%86%E5%90%91101012%E7%9A%84MmIsAddressVaild"><span class="nav-number">11.3.</span> <span class="nav-text">实验三：逆向101012的MmIsAddressVaild</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12%E3%80%8129912%E5%88%86%E9%A1%B5"><span class="nav-number">12.</span> <span class="nav-text">12、29912分页</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">12.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDPTE"><span class="nav-number">12.2.</span> <span class="nav-text">PDPTE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDE"><span class="nav-number">12.3.</span> <span class="nav-text">PDE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XD-x2F-NX%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">12.3.1.</span> <span class="nav-text">XD&#x2F;NX标志位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%AF%BB%E6%89%BE%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">12.4.</span> <span class="nav-text">实验一：手动寻找物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E9%80%86%E5%90%9129912%E7%9A%84MmIsAddressVaild"><span class="nav-number">12.5.</span> <span class="nav-text">实验二：逆向29912的MmIsAddressVaild</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13%E3%80%81PAT-PCD-PWT"><span class="nav-number">13.</span> <span class="nav-text">13、PAT\PCD\PWT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%BC%93%E5%AD%98"><span class="nav-number">13.1.</span> <span class="nav-text">CPU缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.2.</span> <span class="nav-text">缓存类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSR%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.3.</span> <span class="nav-text">MSR寄存器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14%E3%80%81TLB"><span class="nav-number">14.</span> <span class="nav-text">14、TLB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#INVLPG%E6%8C%87%E4%BB%A4"><span class="nav-number">14.1.</span> <span class="nav-text">INVLPG指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9ACR3%E5%88%B7%E6%96%B0TLB"><span class="nav-number">14.2.</span> <span class="nav-text">实验一：CR3刷新TLB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E4%BF%AE%E6%94%B9pte%E7%9A%84G%E4%BD%8D%E7%A6%81%E6%AD%A2%E5%88%B7%E6%96%B0TLB"><span class="nav-number">14.3.</span> <span class="nav-text">实验二：修改pte的G位禁止刷新TLB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9AINVLPG%E5%88%B7%E6%96%B0TLB"><span class="nav-number">14.4.</span> <span class="nav-text">实验三：INVLPG刷新TLB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9ACR4%E5%88%B7%E6%96%B0TLB"><span class="nav-number">14.5.</span> <span class="nav-text">实验四：CR4刷新TLB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15%E3%80%81%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">15、控制寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cr0%EF%BC%88%E5%85%A8%E5%B1%80%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89"><span class="nav-number">15.1.</span> <span class="nav-text">Cr0（全局控制器）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cr1%EF%BC%88%E4%BF%9D%E7%95%99%EF%BC%89"><span class="nav-number">15.2.</span> <span class="nav-text">Cr1（保留）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cr2%EF%BC%88%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="nav-number">15.3.</span> <span class="nav-text">Cr2（缺页异常地址）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cr3%EF%BC%88PDBR%EF%BC%89"><span class="nav-number">15.4.</span> <span class="nav-text">Cr3（PDBR）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cr4%EF%BC%88%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89"><span class="nav-number">15.5.</span> <span class="nav-text">Cr4（个性化控制器）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">PlaneJun</p>
  <div class="site-description" itemprop="description">This is PlaneJun‘s Blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.planejun.cn/2022/10/10/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PlaneJun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlaneJun'Blog">
      <meta itemprop="description" content="This is PlaneJun‘s Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="x86保护模式 | PlaneJun'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          x86保护模式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-10 11:25:00" itemprop="dateCreated datePublished" datetime="2022-10-10T11:25:00+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-12 23:04:00" itemprop="dateModified" datetime="2023-04-12T23:04:00+08:00">2023-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Windows-Kernel/" itemprop="url" rel="index"><span itemprop="name">Windows-Kernel</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="1、保护模式简介"><a href="#1、保护模式简介" class="headerlink" title="1、保护模式简介"></a>1、保护模式简介</h1><p>CPU分有：<code>实模式</code>、<code>保护模式</code>、<code>虚拟8086</code>模式，大多数操作系统都运行在保护模式下。</p>
<p>保护模式主要是用来保护寄存器、数据结构、指令，实际上也就是保护寄存器，因为cpu的数据都存放在寄存器中。</p>
<p>保护模式的特点：段和页。</p>
<ul>
<li>实模式：16位系统DOS，访问的都是物理地址，不安全。</li>
<li>保护模式：将物理地址隔阂后，使用一种线性的虚拟地址来访问，相对实模式来说比较安全。并用段和页的特点来维护虚拟地址。</li>
</ul>
<p>保护模式具体资料可以在 Intel白皮书第三卷 中查看。</p>
<h1 id="2、段寄存器"><a href="#2、段寄存器" class="headerlink" title="2、段寄存器"></a>2、段寄存器</h1><h2 id="2-1-段选择子"><a href="#2-1-段选择子" class="headerlink" title="2.1 段选择子"></a>2.1 段选择子</h2><p>CPU一共有八个段寄存器：ES CS SS DS FS GS LDTR TR ，OD可见前6个，但GS段寄存器windows并未使用（32位下）。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled.jpeg" alt="Untitled"></p>
<p>如果运行在实模式下，则只有前四个有用。</p>
<p>如果是64位，则使用GS而不是FS。</p>
<p>当执行下列汇编代码时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0x12345678],eax</span><br></pre></td></tr></table></figure>

<p>实际上cpu所“看到的”代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[<span class="number">0x12345678</span>],eax</span><br><span class="line"><span class="comment">//ds.base+0x12345678</span></span><br><span class="line"><span class="comment">//cs.base+0x12345678</span></span><br><span class="line"><span class="comment">//ss.base+0x12345678</span></span><br></pre></td></tr></table></figure>

<p>💡 ds段寄存器通常时用来存放要访问数据的段地址。cs段寄存器表示要执行的代码。ss段寄存器表示堆栈的段地址。[…]则表示一个内存单元，比如ds:[1],cs:[1],ss:[1]。——王爽《汇编语言》</p>
<p>段寄存器结构： 共96位， 16位可见，80位不可见。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_1.jpeg" alt="Untitled_1"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegMen</span>&#123;</span>  </span><br><span class="line">  WORD Selector;<span class="comment">//16位  </span></span><br><span class="line">  WORD Attributes;<span class="comment">//16位  </span></span><br><span class="line">  DWORD Base;<span class="comment">//32位  </span></span><br><span class="line">  DWORD Limit;<span class="comment">//32位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>读段寄存器指令：mov ax,es <strong>只能读16位</strong>（可见部分）</p>
<p>写段寄存器指令：mov ds,ax <strong>写了96位的</strong>。</p>
<p>段寄存器可以用mov指令读写，但是LDTR和TR除外。</p>
<p>加载段描述符至段寄存器的指令共有三种：</p>
<ul>
<li>mov ss,ax 使用mov指令</li>
<li><strong>les lss lds lfs lgs</strong>修改对应的段寄存器</li>
<li>cs不能通过上述指令改变，否则会导致EIP的改变，必须保证cs与eip一起改。后文会讲解如何修改CS并在需要时提升权限。</li>
</ul>
<p>其中选择子(Selector)有如下结构：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled.png" alt="Untitled"></p>
<p>打开OD，随便加载一个程序可以看到段寄存器对应的选择子。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_2.jpeg" alt="Untitled_2"></p>
<p>以fs的选择子为例进行解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fs=0x0053 =&gt; 0000 0000 0101 0011</span><br><span class="line">由于前面两个字节为0，因此单独拿后面两个字节讲解。</span><br><span class="line">0101 0011</span><br><span class="line">根据上面给出的Selector表可以对这两个字节划分。</span><br><span class="line">01010 0 11</span><br><span class="line"></span><br><span class="line">值     |    含义</span><br><span class="line">- ------------------------------------------------</span><br><span class="line">01010  |    欲查表的索引号,此处为十进制5</span><br><span class="line">0      |    欲查哪一块表;0-&gt;GDT 1-&gt;LDT</span><br><span class="line">11     |    哪一环的权限(RPL),此处为十进制3,因此为3环</span><br><span class="line">根据公式 addr = GDT + 8 * index计算后可得到fs的段描述符</span><br><span class="line">addr = 0xfffff88004590000 + 8 * 5 = 0xfffff88004590028</span><br><span class="line"></span><br><span class="line">2: kd&gt; dq fffff88004590028</span><br><span class="line">fffff880`04590028  **00cff300`0000ffff** 0020fb00`00000000</span><br><span class="line">fffff880`04590038  00000000`00000000 04008b58`f0000067</span><br><span class="line">fffff880`04590048  00000000`fffff880 ff40f3fd`f000bc00</span><br><span class="line">fffff880`04590058  00000000`00000000 00cf9a00`0000ffff</span><br><span class="line">fffff880`04590068  00000000`00000000 00000000`00000000</span><br><span class="line">fffff880`04590078  00000000`00000000 00000000`00000000</span><br><span class="line">fffff880`04590088  00000000`00000000 00000000`00000000</span><br><span class="line">fffff880`04590098  00000000`00000000 00000000`00000000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GDT：全局描述表（Global Description Table），在操作系统加载完毕后就存在的一快内存。实际上就是一个数组，每一个元素就是一个描述符，多个组合一起就构成了全局描述符表。而每一个描述符共64位，包含了以下的这些信息：段基址、段长度、属性。段寄存器通过解析选择子后得到索引后在GDT中跳转获取对应描述符。</p>
</blockquote>
<blockquote>
<p>LDT：局部描述表（Local Description Table），与GDT功能一致，但不能单独存在，只能嵌套在GDT中。</p>
</blockquote>
<ul>
<li><strong>windbg获取GDT</strong></li>
</ul>
<p>GDT可以使用windbg的命令可以查看gdt表的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdtr寄存器（windbg伪寄存器，是windbg通过sgdt lgdt指令获取的，为了方便用户，才模拟了一个寄存器叫gdtr，实际是没有这个寄存器的） :</span><br><span class="line">存两个值，一个是GDT表的首地址，一个是GDT表的大小(字节为单位)   48位 </span><br><span class="line">r gdtr  r查看gdtr寄存器的地址</span><br><span class="line">r gdtl  r查看gdtr寄存器的大小  都查gdtr</span><br><span class="line">dd  xxxx       4字节查看内存</span><br><span class="line">dq  XXXX       8字节查看内存</span><br><span class="line">dq  xxxx Lnum    查看固定数量元素的内存</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_3.jpeg" alt="Untitled_3"></p>
<ul>
<li><strong>r3代码获取GDT</strong></li>
</ul>
<p>通过指令sgdt获取。其中共获取到6个字节,前两个字节位gdt寄存器的大小,后面四个字节为gdt的地址。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_1.png" alt="Untitled_1"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> var[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		sgdt var</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x\n&quot;</span>,*(<span class="type">unsigned</span> <span class="type">int</span>*)&amp;var[<span class="number">2</span>],*(<span class="type">unsigned</span> <span class="type">short</span>*)&amp;var[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_2.png" alt="Untitled_2"></p>
<h2 id="2-2-段描述符"><a href="#2-2-段描述符" class="headerlink" title="2.2 段描述符"></a>2.2 段描述符</h2><p>段描述符有如下结构：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_3.png" alt="Untitled_3"></p>
<p>将gdt的一个段描述符<code>0x00cff300 0000ffff</code>进行拆分可得到如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">base:0x00000000</span><br><span class="line">attr:0x0cf3(前面的0是补齐2字节)</span><br><span class="line">limit:0xfffff(前面的0是补齐4字节)</span><br><span class="line"></span><br><span class="line">attr的属性又可以细分如下：</span><br><span class="line">0xc = 1100</span><br><span class="line">----------------------------</span><br><span class="line">G:1;1-&gt;limit以4k对齐,limit = ( limit + 1 ) * 4096 - 1    0-&gt;字节对齐,limit = limit</span><br><span class="line">D/B:1</span><br><span class="line">0:0</span><br><span class="line">AVL:0</span><br><span class="line"></span><br><span class="line">0xf3 = 1111 0011</span><br><span class="line">-----------------------------</span><br><span class="line">P:1</span><br><span class="line">DPL:11</span><br><span class="line">S:1</span><br><span class="line">Type:0011(3)</span><br></pre></td></tr></table></figure>

<h3 id="G位"><a href="#G位" class="headerlink" title="G位"></a>G位</h3><p>段对齐粒度。 也就是决定了Limit大小的一个位。</p>
<p>在上文填充段寄存器隐藏部分时，Limit在描述符中只有5个16进制位表示，剩下的3个16进制位就需要看G位。</p>
<p>当G为0时，整个段将以字节对齐，Limit大小单位为字节，所以精确到1。Limit直接就是段长。段寄存器中的Limit高位补0。</p>
<p>当G为1时，整个段将以4KB对齐，Limit大小单位为4KB，所以段的末尾处一定是以FFF结尾。段寄存器中的Limit低位补FFF。</p>
<h3 id="D-x2F-B位"><a href="#D-x2F-B位" class="headerlink" title="D&#x2F;B位"></a>D&#x2F;B位</h3><p><strong>&#x3D;0</strong>表示是16位的单位,<strong>&#x3D;1</strong>表示32位的单位。</p>
<p>如果是代码段的描述符,那么称为D;如果是数据段的描述符,称为B。</p>
<p>大段或者小段，分为三种情况：</p>
<p><strong>对CS段来说：</strong></p>
<p>为1时，默认为32位寻址。</p>
<p>为0时，默认为16位寻址。</p>
<p>前缀67改变寻址方式。</p>
<p><strong>对SS段来说：</strong></p>
<p>为1时，隐式堆栈访问指令（PUS H POP CALL RETN等）修改的是32位寄存器ESP</p>
<p>为0时，隐式堆栈访问指令（PUSH POP CALL RETN等）修改的是16位寄存器SP</p>
<p>对于向下扩展的数据段：</p>
<p>为1时，段上限大小为4GB(2的32次方)。 为0时 段上限大小为64KB(2的16次方)。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_4.png" alt="Untitled_4"></p>
<h3 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h3><p>有效位 1：描述符有效 0：描述符无效</p>
<p>当描述符无效时，任何尝试加载该描述符、访问该描述符对应的段间地址都会报错。</p>
<h3 id="DPL位"><a href="#DPL位" class="headerlink" title="DPL位"></a>DPL位</h3><p>能访问段描述符的权限。</p>
<p>💡  RPL：发出请求的权限等级。</p>
<p>​	CPL：当前请求的权限等级。一般特指为CS的RPL。</p>
<p>​	DPL：能否访问段描述符的权限等级。</p>
<p>​	三者的联系可总结为：<code>在CPL的权限下，以RPL的权限去访问DPL权限。</code></p>
<h3 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h3><pre><code>描述符类型位。 为0时，是系统段描述符。 为1时，是代码或数据段描述符。具体类型需要搭配type属性来判断。
</code></pre>
<h3 id="Type位"><a href="#Type位" class="headerlink" title="Type位"></a>Type位</h3><p>由S位决定了具体是代码段还是数据段描述符</p>
<ul>
<li><strong>当S&#x3D;1,type表示为数据段的描述</strong></li>
</ul>
<blockquote>
<p>数据段： A位：数据段是否被访问过位，访问过为1，未访问过为0  段描述符是否被加载过 W位：数据段是否可写位，可写为1，不可写为0 E位：向下扩展位，0向上扩展：段寄存器.base+limit区域可访问。1向下扩展：除了base+limit以外的部分可访问。</p>
</blockquote>
<blockquote>
<p>代码段： A位：代码段是否被访问过位，访问过为1，未访问过为0  段描述符是否被加载过 R位：代码段是否可读位，可读为1，不可读为0。(但R位为0,代码段照样可以读) C位：一致位。1：一致代码段(0环的函数在3环可以调用)。   0：非一致代码段(各调各的)</p>
</blockquote>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_5.png" alt="Untitled_5"></p>
<ul>
<li><strong>当S&#x3D;0,type表示为系统描述,门</strong></li>
</ul>
<p>(小于8是16位的系统描述,大于8是32位)</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_17.png" alt="Untitled_17"></p>
<h3 id="针对E位的理解与实验："><a href="#针对E位的理解与实验：" class="headerlink" title="针对E位的理解与实验："></a>针对E位的理解与实验：</h3><p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_6.png" alt="左边为向上扩展,右边为向下扩展。红色代表可以访问,绿色不可访问"></p>
<p>左边为向上扩展,右边为向下扩展。红色代表可以访问,绿色不可访问</p>
<p><code>Tip:段描述符有没有4G,首先是看E位的拓展方向,其次是看Base和limit之间的大小。</code></p>
<p>首先构造一条段描述符.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00cff700`0000ffff</span><br><span class="line"></span><br><span class="line">base:00000000 </span><br><span class="line">attr:0cf7 </span><br><span class="line">limit:fffff   ;由于G位是1所以这里实际为(0xfffff+1) * 0x1000 - 1 = 0xFFFFFFFF</span><br><span class="line"></span><br><span class="line">E位:0111,向下扩展</span><br></pre></td></tr></table></figure>

<p>通过windbg的<code>e[b|d|D|f|p|q|w] address [Values]</code>指令可以修改GDT中保存的段描述符。修改8003f090(GDTR &#x3D; 8003f000),然后输出gdt查看前20个描述表,<code>dq address l20</code>。(注意是小写L,不是数字1)。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_7.png" alt="Untitled_7"></p>
<hr>
<h4 id="实验一：ds"><a href="#实验一：ds" class="headerlink" title="实验一：ds"></a>实验一：ds</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code1:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> var = <span class="number">0</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">_asm&#123;</span><br><span class="line">mov ax,<span class="number">0x93</span> <span class="comment">//10010 011 -&gt; index = 18 * 8 = 144 (0x90)</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov dword ptr ds:[var],<span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,var);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行出错。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_8.png" alt="Untitled_8"></p>
<p><strong>分析：</strong>异常断在了赋值var的地方。首先在描述符中attr为0x0cf7,Type&#x3D;0111表示为向下扩展、可读写、已访问。根据上图可知,如果E位为向下扩展,则base+limit这段区域是无法访问的即(0x00000000-0xffffffff),因此在写数据时发生了错误。<strong>修复方法为将E位修改为向上扩展(E&#x3D;0)，或者将limit修改为一个小范围值,使得其他区域的内存可以访问(在demo2实现)。</strong></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_9.png" alt="Untitled_9"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_10.png" alt="Untitled_10"></p>
<p>实验成功!</p>
<hr>
<h4 id="实验二：ss"><a href="#实验二：ss" class="headerlink" title="实验二：ss"></a>实验二：ss</h4><p>首先将0x8003f090修改回0x00cff700&#96;0000ffff。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> var = <span class="number">0</span>; <span class="comment">//局部变量</span></span><br><span class="line">_asm&#123;</span><br><span class="line">mov ax,<span class="number">0x93</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov dword ptr ds:[var],<span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,var);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行同样报错。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_11.png" alt="Untitled_11"></p>
<p><strong>分析：</strong>需要注意的是中断打在了printf上,说明我们上边的ASM代码没问题!那么一个新问题来了,为什么demo1中中断打在了var赋值上?虽然我们显式使用了ds段来描述变量var,但仍存在一个问题,<strong>变量var属于堆栈地址</strong>,所以实际上<code>mov dword ptr ds:[var]</code>被编译器翻译成了<code>mov dword ptr ss:[var]</code></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_12.png" alt="Untitled_12"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_13.png" alt="Untitled_13"></p>
<p>因为我们没有修改ss段,所以上面对ss段的操作没问题。根据单步执行,可以发现中断的位置是printf函数。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_14.png" alt="Untitled_14"></p>
<p>根据我们构造的描述符可知,base&#x3D;0,limit的范围为0xFFFFFFFF,然后又属于向下扩展,所以0x0-0xFFFFFFFF的区域无法访问,printf中必然有用到ds段的数据,但这些数据有没有访问权限,因此访问中断了。<strong>修复方法为将limit设置为一个很小的范围,这样其他的区域就可以访问了。比如0x1FFF。(00c0f700&#96;00000001)</strong></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_15.png" alt="Untitled_15"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_16.png" alt="Untitled_16"></p>
<p>实验完成!</p>
<hr>
<p>使用windbg的<code>dg segment</code>命令可以快速查看段寄存器对应的段描述符。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_4.jpeg" alt="Untitled_4"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_5.jpeg" alt="Untitled_5"></p>
<h2 id="2-3-段寄存器证明"><a href="#2-3-段寄存器证明" class="headerlink" title="2.3 段寄存器证明"></a>2.3 段寄存器证明</h2><p>读的时候只能读到16位(选择子)，但写的时候却写入了96位。如何证明剩下的80位是否存在？</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Untitled_6.jpeg" alt="Untitled_6"></p>
<ul>
<li><strong>Attribute探测</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov ax,ss                <span class="comment">//ss可读可写</span></span><br><span class="line">		mov ds,ax                <span class="comment">//ds可读可写</span></span><br><span class="line">		mov dword ptr ds:[var],eax        <span class="comment">//ds此时为ss，不报错，说明两个段寄存器权限相同</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line">		__asm&#123;</span><br><span class="line">			mov ax,cs            <span class="comment">//cs可读可执行不可写</span></span><br><span class="line">			mov ds,ax            <span class="comment">//ds可读可写</span></span><br><span class="line">			mov dword ptr ds:[var],eax        <span class="comment">//ds此时为cs，写入时报错，说明Attribute属性存在</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Base探测</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov ax,fs            <span class="comment">//fs 的 base为TEB  用ds编译不过去</span></span><br><span class="line">		mov gs,ax            <span class="comment">//gs 的 base为0</span></span><br><span class="line">		mov eax,gs:[<span class="number">0</span>]        <span class="comment">//gs此时为fs，写入不出错，说明Base属性存在  fs.base+0</span></span><br><span class="line">		mov dword ptr gs:[var],eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Limit探测</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line">	__asm&#123;</span><br><span class="line">		mov ax,fs            <span class="comment">//fs 的 base为TEB  用ds编译不过去</span></span><br><span class="line">		mov gs,ax            <span class="comment">//gs 的 base为0</span></span><br><span class="line">		mov eax,gs:[<span class="number">0x1000</span>]        <span class="comment">//写入出错，超过了fs的limit，说明Limit属性存在 fs.base+0x1000</span></span><br><span class="line">		<span class="comment">//mov eax,ds:[0x7FFDF000+0x1000]  不报错</span></span><br><span class="line">		mov dword ptr gs:[var],eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-段寄存器权限"><a href="#2-4-段寄存器权限" class="headerlink" title="2.4 段寄存器权限"></a>2.4 段寄存器权限</h2><h3 id="数据段："><a href="#数据段：" class="headerlink" title="数据段："></a>数据段：</h3><blockquote>
<p>mov ds,ax	&#x2F;&#x2F;当执行 mov ds,ax 时，CPU先解析段选择子0020，然后去GDT表找段描述符，检查段描述符P位是否有效，然后检查S位，确认是数据段或代码段，然后检查TYPE域确认是数据段，然后看DPL是否能够访问.只要上述条件都满足，则mov指令执行成功，只要有一条不满足，mov失败。</p>
</blockquote>
<h4 id="实验一：CPL-x3D-3-RPL-x3D-3-DPL-x3D-3"><a href="#实验一：CPL-x3D-3-RPL-x3D-3-DPL-x3D-3" class="headerlink" title="实验一：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3"></a>实验一：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3</h4><p>修改GDT+0x48为 00cff300&#96;0000ffff</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		mov ax,<span class="number">0x4B</span> <span class="comment">//RPL=3 CPL=3 DPL=3</span></span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov dword ptr[var],<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行正常！</p>
<h4 id="实验二：CPL-x3D-3-RPL-x3D-0-DPL-x3D-3"><a href="#实验二：CPL-x3D-3-RPL-x3D-0-DPL-x3D-3" class="headerlink" title="实验二：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;3"></a>实验二：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;3</h4><p>修改GDT+0x48为 00cff300&#96;0000ffff</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		mov ax,<span class="number">0x48</span> <span class="comment">//RPL=0 CPL=3 DPL=3</span></span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov dword ptr[var],<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行正常！</p>
<h4 id="实验三：CPL-x3D-3-RPL-x3D-3-DPL-x3D-0"><a href="#实验三：CPL-x3D-3-RPL-x3D-3-DPL-x3D-0" class="headerlink" title="实验三：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;0"></a>实验三：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;0</h4><p>修改GDT+0x48为 00cf9300&#96;0000ffff</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		mov ax,<span class="number">0x4B</span> <span class="comment">//RPL=3 CPL=3 DPL=0</span></span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov dword ptr[var],<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行失败！</p>
<h4 id="实验四：CPL-x3D-3-RPL-x3D-0-DPL-x3D-0"><a href="#实验四：CPL-x3D-3-RPL-x3D-0-DPL-x3D-0" class="headerlink" title="实验四：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;0"></a>实验四：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;0</h4><p>修改GDT+0x48为 00cf9300&#96;0000ffff</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		mov ax,<span class="number">0x48</span> <span class="comment">//RPL=3 CPL=3 DPL=0</span></span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov dword ptr[var],<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行失败！</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>数据段下<code>RPL&lt;=DPL &amp;&amp; CPL&lt;=DPL(数值上)</code>，实验四失败是因为此时运行的环境为3环。</p>
<h3 id="代码段（跨段跳转-不提权）："><a href="#代码段（跨段跳转-不提权）：" class="headerlink" title="代码段（跨段跳转-不提权）："></a>代码段（跨段跳转-不提权）：</h3><p>跳转指令有call、jmp两种，格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL FAR CS:EIP</span><br><span class="line">JMP  FAR CS:EIP</span><br><span class="line"></span><br><span class="line">;CALL/JMP FAR 0x20:0x004183D7</span><br><span class="line">;0x20为新的cs寄存器，通过拆分新的cs寄存器得到段描述符后根据其base+0x004183D7进行跳转。</span><br></pre></td></tr></table></figure>

<p>为了避免干扰，需要关闭<code>增量链接</code>和<code>随机地址</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028142955249.png" alt="image-20221028142955249"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028142922784.png" alt="image-20221028142922784"></p>
<h4 id="长跳转与短跳转"><a href="#长跳转与短跳转" class="headerlink" title="长跳转与短跳转"></a>长跳转与短跳转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">汇编写法：</span><br><span class="line">call/jmp far cs:eip</span><br><span class="line"></span><br><span class="line">C++写法：</span><br><span class="line">char buf[6]=&#123;78,56,34,12,0x4b,0&#125;; </span><br><span class="line">call/jmp fword ptr [buf] // call 4b:12345678</span><br></pre></td></tr></table></figure>

<p>长跳转的压栈与短跳转(普通的call)压栈略有区别。短跳转会将下一行代码的地址入栈后进行跳转；而长跳转会将当前cs和下一行代码的地址入栈再跳转。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028171858280.png" alt="image-20221028171858280"></p>
<p>执行前</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028172347806.png" alt="image-20221028172347806"></p>
<p>执行后</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028172310947.png" alt="image-20221028172310947"></p>
<p>因此ret指令已经不适合长跳转的返回，取而代之的是<code>retf</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028172807035.png" alt="image-20221028172807035"></p>
<h4 id="实验一：CPL-x3D-3-RPL-x3D-3-DPL-x3D-3-1"><a href="#实验一：CPL-x3D-3-RPL-x3D-3-DPL-x3D-3-1" class="headerlink" title="实验一：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3"></a>实验一：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3</h4><p>构造描述符00cffb00&#96;0000ffff(type:1011，非一致代码段)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;; <span class="comment">//前四个字节为跳转的地址,后两个字节为新的CS</span></span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr [buf]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行正常！</p>
<h4 id="实验二：CPL-x3D-3-RPL-x3D-0-DPL-x3D-3-1"><a href="#实验二：CPL-x3D-3-RPL-x3D-0-DPL-x3D-3-1" class="headerlink" title="实验二：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;3"></a>实验二：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;3</h4><p>构造描述符00cffb00&#96;0000ffff(type:1011，非一致代码段)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;; <span class="comment">//前四个字节为跳转的地址,后两个字节为新的CS</span></span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr [buf]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行正常,但会发现cs并没有被修改为0x48。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028184231219.png" alt="image-20221028184231219"></p>
<p><strong>原因：长跳转时有那么一个计算 RPL|DPL -&gt; 0|3 &#x3D; 3 &#x3D;&gt; 4B</strong></p>
<h4 id="实验三：CPL-x3D-3-RPL-x3D-3-DPL-x3D-0-1"><a href="#实验三：CPL-x3D-3-RPL-x3D-3-DPL-x3D-0-1" class="headerlink" title="实验三：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;0"></a>实验三：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;0</h4><p>构造描述符00cf9b00&#96;0000ffff(type:1011，非一致代码段)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;; <span class="comment">//前四个字节为跳转的地址,后两个字节为新的CS</span></span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr [buf]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行失败！</p>
<h4 id="实验四：CPL-x3D-3-RPL-x3D-0-DPL-x3D-0-1"><a href="#实验四：CPL-x3D-3-RPL-x3D-0-DPL-x3D-0-1" class="headerlink" title="实验四：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;0"></a>实验四：CPL&#x3D;3 RPL&#x3D;0 DPL&#x3D;0</h4><p>构造描述符00cf9b00&#96;0000ffff(type:1011，非一致代码段)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;; <span class="comment">//前四个字节为跳转的地址,后两个字节为新的CS</span></span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr [buf]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行失败！</p>
<h4 id="实验五：CPL-x3D-3-RPL-x3D-3-DPL-x3D-3-（retf）"><a href="#实验五：CPL-x3D-3-RPL-x3D-3-DPL-x3D-3-（retf）" class="headerlink" title="实验五：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3 （retf）"></a>实验五：CPL&#x3D;3 RPL&#x3D;3 DPL&#x3D;3 （retf）</h4><p>构造描述符00cffb00&#96;0000ffff(type:1011，非一致代码段)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;; <span class="comment">//前四个字节为跳转的地址,后两个字节为新的CS</span></span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr [buf]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在retf处下断点，然后修改保存的cs为18（0环）。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028191429965.png" alt="image-20221028191429965"></p>
<p>然后运行，发现异常。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028191518915.png" alt="image-20221028191518915"></p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>跨段代码无法进行提权（提权需要门）。</p>
<p>然后火哥是这么说的!!!!!</p>
<ul>
<li>JMP和CALL 只能用于同权限，或者往高权限跳。(实验一到实验五我是没看出来这个，但是火哥说了就先记住！嘤嘤嘤~~~~)</li>
<li>retf 和 iretd 只能用于同权限，或者往低权限返回。(根据实验五可以推测出来)</li>
</ul>
<h1 id="3、调用门"><a href="#3、调用门" class="headerlink" title="3、调用门"></a>3、调用门</h1><p>门，通往新世界的通道。与长跳转类似也是通过<code>call far cs:eip(jmp不行)</code>进行调用。当cs对应的段描述符的S&#x3D;0时，CPU会识别这个描述符是一个门，每个门格式不同。调用门格式如下：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028194713225.png" alt="image-20221028194713225"></p>
<ul>
<li><p>P：表示该描述符是否有效。</p>
</li>
<li><p>DPL：当前描述符的权限。</p>
</li>
<li><p>Type:1100，表明是一个调用门。</p>
</li>
<li><p>ParamCount：调用参数个数。</p>
</li>
<li><p>Segment Selector:门的选择子。</p>
</li>
<li><p>Offset in Segment:门的偏移，跳转地址：门的选择子.base + 偏移。</p>
</li>
</ul>
<h2 id="实验一：提权R3进入R0环"><a href="#实验一：提权R3进入R0环" class="headerlink" title="实验一：提权R3进入R0环"></a>实验一：提权R3进入R0环</h2><p>构造一个3环-&gt;0环的描述符<code>1234EC00·00085678</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offset in segment:0x12345678</span><br><span class="line">segment selector:0x0008 -&gt; 1 0 00 (0环权限，查GDT，index=1)</span><br><span class="line">p:1</span><br><span class="line">dpl:3</span><br><span class="line">param count:0</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	_asm&#123;</span><br><span class="line">		<span class="type">int</span> <span class="number">3</span></span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr buf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在printf下断点，查看函数test地址后填充到门描述符。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028200858575.png" alt="image-20221028200858575"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028200959253.png" alt="image-20221028200959253"></p>
<p>然后单步执行调用门后int 3断点被执行。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028201116857.png" alt="image-20221028201116857"></p>
<p>使用<code>u[f] addr [-lxxxx]</code>查看汇编,其中f可以直接查看函数的所有汇编。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028201232089.png" alt="image-20221028201232089"></p>
<p>说明此时已经跨段提权进入0环。输入g命令继续执行，此时发现r3层异常中断，原因为int 3造成,去掉int 3即可正常运行。</p>
<p>与长跳转不同的是，由于调用门为R3进入到R0，由于两个权限的地址范围和权限不同，因此调用门在call的时候会将ss、esp、cs、下一行代码地址，进行入栈。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028202041627.png" alt="image-20221028202041627"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028202349714.png" alt="image-20221028202349714"></p>
<h2 id="实验二：调用0环函数-DbgPrint"><a href="#实验二：调用0环函数-DbgPrint" class="headerlink" title="实验二：调用0环函数(DbgPrint)"></a>实验二：调用0环函数(DbgPrint)</h2><p>首先使用<code>uf nt!DbgPrint</code>获取函数地址</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028202522357.png" alt="image-20221028202522357"></p>
<p>然后添加函数声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(__cdecl *fnDbgPrint)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * _Format, ...)</span>;</span><br><span class="line"></span><br><span class="line">fnDbgPrint myDbgPrint = (fnDbgPrint)<span class="number">0x83e4fc60</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> msg[]=<span class="string">&quot;fuking man!!!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	_asm&#123;</span><br><span class="line">		pushfd</span><br><span class="line">		pushad</span><br><span class="line">		push fs	<span class="comment">//保存R3的fs</span></span><br><span class="line">		mov ax, <span class="number">0x30</span><span class="comment">//切换R0的fs</span></span><br><span class="line">		mov fs, ax;</span><br><span class="line"></span><br><span class="line">		lea eax, [msg]</span><br><span class="line">		push eax</span><br><span class="line">		call myDbgPrint</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">		pop fs	<span class="comment">//恢复R3的fs</span></span><br><span class="line">		popad</span><br><span class="line">		popfd</span><br><span class="line"></span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	*(<span class="type">int</span>*)&amp;buf[<span class="number">0</span>]=(<span class="type">int</span>)test;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		call fword ptr buf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开dbgView进行监视。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028203140417.png" alt="image-20221028203140417"></p>
<p>运行R3程序。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221028203401508.png" alt="image-20221028203401508"></p>
<p>成功输出，但是不知道为啥DbgView没捕获到。</p>
<blockquote>
<p>补充：设置完DbgView了之后重新打开就行了。</p>
</blockquote>
<h1 id="4、中断门"><a href="#4、中断门" class="headerlink" title="4、中断门"></a>4、中断门</h1><blockquote>
<p>硬件叫做中断，软件叫做异常。</p>
</blockquote>
<p>中断门，CPU执行如下的指令：<code>INT N</code>，查询的是另外一张表，这张表叫IDT表。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029154208996.png" alt="image-20221029154208996"></p>
<p>表的含义与调用门基本一致。这里面的D代表了default默认是1。windbg同样也提供了类似GDT表查询的指令,<code>r idtr</code>、<code>r idtl</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029154542770.png" alt="image-20221029154542770"></p>
<p>使用<code>dq idtr</code>查看idt表。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029154614726.png" alt="image-20221029154614726"></p>
<p>其中每个中断描述符代表了一个中断函数。常见R3层的int 3指令对应的是<code>83e5ee00·00084fc0</code>，拆分后得到的中断函数(Offset)为0x83e54fc0,使用windbg查看该地址的反汇编。</p>
<blockquote>
<p>int3 与 int 3作用相同,都是查询IDT表index为3的描述符。但int3只有一个字节(0xCC),int 3占两个字节(CD 03)</p>
</blockquote>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029155527981.png" alt="image-20221029155527981"></p>
<p>windbg同样提供了<code>!idt n</code>指令用于查看对应中断序号的中断函数。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029155648779.png" alt="image-20221029155648779"></p>
<h2 id="实验一：构造中断门"><a href="#实验一：构造中断门" class="headerlink" title="实验一：构造中断门"></a>实验一：构造中断门</h2><blockquote>
<p>关闭增量链接和随机地址。</p>
</blockquote>
<p>首先获取函数地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		iretd	<span class="comment">//中断门使用的是iretd,d代表dword，32位。实模式(16)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029161147825.png" alt="image-20221029161147825"></p>
<p>然后构造描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset:<span class="number">0x00401000</span></span><br><span class="line">segment selector:<span class="number">0008</span>（<span class="number">0</span>环）</span><br><span class="line">P：<span class="number">1</span></span><br><span class="line">DPL：<span class="number">3</span>（确保<span class="number">3</span>环有权限访问该中断描述符）</span><br><span class="line"></span><br><span class="line">=<span class="number">0040</span>EE00`<span class="number">00081000</span></span><br></pre></td></tr></table></figure>

<p>然后在idtr+0x100处写入我们的描述符。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029161254790.png" alt="image-20221029161254790"></p>
<p>代码中添加int的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	getchar();</span><br><span class="line">	_asm&#123;</span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span>   <span class="comment">//0x100 / 0x8 = 0x20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，windbg中断。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029162514739.png" alt="image-20221029162514739"></p>
<p>输入g命令继续执行，此时发现r3层异常中断，原因为int 3造成,去掉int 3即可正常运行。</p>
<h2 id="实验二：堆栈影响"><a href="#实验二：堆栈影响" class="headerlink" title="实验二：堆栈影响"></a>实验二：堆栈影响</h2><p>重新运行实验一的代码，在执行int 0x20前，观察寄存器和段寄存器的值。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029162813573.png" alt="image-20221029162813573"></p>
<p>然后继续执行。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029162956265.png" alt="image-20221029162956265"></p>
<p>可以看到中断门先后压入了ss、esp、efl、cs、下一条语句的地址。因此进入中断门的堆栈结构如下：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030123121116.png" alt="image-20221030123121116"></p>
<h2 id="实验三：IF"><a href="#实验三：IF" class="headerlink" title="实验三：IF"></a>实验三：IF</h2><p>将代码修改为如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		</span><br><span class="line">		pushfd</span><br><span class="line">		pop eax</span><br><span class="line">		mov dword ptr [val],eax  <span class="comment">//获取efl</span></span><br><span class="line">		<span class="type">int</span> <span class="number">3</span></span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	getchar();</span><br><span class="line">	_asm&#123;</span><br><span class="line">		pushfd   <span class="comment">//保存环境</span></span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">		popfd</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,val);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后windbg断下，输入<code>dds esp</code>查看堆栈</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030122710511.png" alt="image-20221030122710511"></p>
<p>堆栈值未变，那么输入<code>uf 401000</code>查看一下函数的反汇编.</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030122744380.png" alt="image-20221030122744380"></p>
<p>dd一下变量val的值。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030122813632.png" alt="image-20221030122813632"></p>
<p>神奇的发现堆栈中保存的efl与获取到的efl不一样！！！！！！原因是，int 3同时也是进入中断门，因此当前堆栈保存的是int 3的efl。分别将0x46和0x246转换为二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x046 = 0000 0100 0110</span><br><span class="line">0x246 = 0010 0100 0110</span><br></pre></td></tr></table></figure>

<p>可以发现第九位有区别，第九位在eflags文档中为IF为，中断启用标志。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221029164026531.png" alt="image-20221029164026531"></p>
<ul>
<li><p><strong>可屏蔽中断请求</strong>：如键盘输入，鼠标点击都是一次可屏蔽中断请求。</p>
</li>
<li><p><strong>不可屏蔽中断请求：</strong>CPU必须立即无条件响应的请求，如电源断电。</p>
</li>
</ul>
<p>大概意思就是我们自己的int 0x20中断后无法对鼠标或者键盘之类的外设输入进行响应，但是int 3可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cli; //清除Efl的IF位 </span><br><span class="line">sti; //设置Efl的IF位</span><br></pre></td></tr></table></figure>

<p>然后火哥说中断门会清空VM、TF、NF、IF位。</p>
<ul>
<li><p>VM（Vitual-8086 Mode）：虚拟8086模式，这个是为了16位兼容，在C:\windows下除了有system32还有一个是system(实模式)。当这个为1时表示运行在一个虚拟的16位系统（可分页可分段，访问的不是物理地址）。</p>
</li>
<li><p>TF（Trap Flag）：单步位（相当于OD的F7，F8不算单步，因为他跳过了call），如果为1表示下一行代码执行时会发生异常。</p>
</li>
<li><p>NT（Nested Task）：任务嵌套位。为1时有上一层要返回。</p>
</li>
</ul>
<p>中断门之所以会清空这三个标志位是因为防止中断嵌套</p>
<p>可以理解为清空IF是为了防止其他中断打断；清空TF是防止在执行中断门里边的代码时一直异常；清空NF位是为了防止执行完就会返回（<code>有点还不太了解，因为还没学到任务门</code>）；清空VM位不是很理解。</p>
<blockquote>
<p>调用门与中断门的区别是，<u>调用门能被可屏蔽中断打断。</u></p>
</blockquote>
<h1 id="5、陷阱门"><a href="#5、陷阱门" class="headerlink" title="5、陷阱门"></a>5、陷阱门</h1><p>陷阱门的格式与中断门一致，唯独不同的地方就是Type位。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030124607785.png" alt="image-20221030124607785"></p>
<h2 id="实验一：VM、TF、IF、NT"><a href="#实验一：VM、TF、IF、NT" class="headerlink" title="实验一：VM、TF、IF、NT"></a>实验一：VM、TF、IF、NT</h2><p>将中断门的描述符改为0040EF00&#96;00081000</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030124837901.png" alt="image-20221030124837901"></p>
<p>然后执行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm&#123;</span><br><span class="line">		</span><br><span class="line">		pushfd</span><br><span class="line">		pop eax</span><br><span class="line">		mov dword ptr [val],eax</span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	getchar();</span><br><span class="line">	_asm&#123;</span><br><span class="line">		pushfd</span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">		popfd</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,val);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到此时EFL为246.</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221030124917851.png" alt="image-20221030124917851"></p>
<p>说明它禁止响应可屏蔽中断。</p>
<blockquote>
<p>IDT中没有用到陷阱门。</p>
</blockquote>
<p>然后中断门和陷阱门的区别就是：中断门由于IF为为0，表明不会被其他中断打断，而陷阱门有可能会被打断。</p>
<h1 id="6、任务段"><a href="#6、任务段" class="headerlink" title="6、任务段"></a>6、任务段</h1><p>任务段(TSS：Task-State Segment)描述的是一个任务环境，用于进程和线程的环境的切换。TSS是一种<code>结构数据</code>且保存在内存中。内存的位置被描述在GDT中。</p>
<p>由于任务太过依赖于GDT表中的任务段描述和内存块，因此Windows 和Linux 都没有采用任务段（不想被CPU限制）。</p>
<p>TSS结构如下：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031142520796.png" alt="image-20221031142520796"></p>
<ul>
<li>ESP0、SS0：从R3切换至R0时，切换的堆栈数据。</li>
<li>EIP：任务的地址地址。</li>
<li>通用寄存器、段选择子、EFLAGS：自定义。</li>
<li>CR3：来源R3</li>
<li>Previous Task Link：上一个TSS的选择子。</li>
</ul>
<p><code>TSS是最小104字节的内存</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Avoid placing a page boundary in the part of the TSS that the processor reads during a task switch (the first 104</span><br><span class="line">bytes). The processor may not correctly perform address translations if a boundary occurs in this area. During</span><br><span class="line">a task switch, the processor reads and writes into the first 104 bytes of each TSS (using contiguous physical</span><br><span class="line">addresses beginning with the physical address of the first byte of the TSS). So, after TSS access begins, if part</span><br><span class="line">of the 104 bytes is not phy</span><br><span class="line"></span><br><span class="line">避免在TSS中处理器在任务切换期间读取的部分(前104字节)。如果该区域出现边界，处理器可能无法正确执行地址转换。在一个任务开关，处理器读写每个TSS的前104(0x68)个字节(使用连续的物理以TSS的第一个字节的物理地址开头的地址)。因此，在TSS访问开始后，如果部分在这104个字节不是物理连续的，处理器将访问不正确的信息而不生成一个页面错误异常。</span><br></pre></td></tr></table></figure>

<p>在windbg中使用命令<code>dt structName [addr]</code>来查看结构体数据，查看TSS命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _KTSS</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031143307127.png" alt="image-20221031143307127"></p>
<p>TSS同样有str和ltr指令。str用于获取、ltr用于加载。但不同的是,tr保存的是一个选择子。windbg中使用命令<code>r tr</code>，获取选择子。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031143448888.png" alt="image-20221031143448888"></p>
<p>0x28拆分得到index后可寻址到描述TSS的描述符，也可以使用<code>dg</code>命令。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031143703152.png" alt="image-20221031143703152"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031144646917.png" alt="image-20221031144646917"></p>
<p>描述TSS的描述符结构如下：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031144418041.png" alt="image-20221031144418041"></p>
<p>描述符的结构与段描述符基本一致，需要注意的有两个地方，<u>一个是Type位的B表示的是Busy，即当前任务是否处于忙碌状态(是否在执行)，1表示忙碌，0表示非忙碌。Base表示Tss这块内存数据保存的地址。</u></p>
<p>此时重新使用dt命令解析TSS。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031145236635.png" alt="image-20221031145236635"></p>
<p>可以看到Flags为0x8b,b&#x3D;1011,B&#x3D;1表示busy。</p>
<h2 id="实验一：构造任务段"><a href="#实验一：构造任务段" class="headerlink" title="实验一：构造任务段"></a>实验一：构造任务段</h2><blockquote>
<p>关闭增量链接、关闭地址随机</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x2024 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR DirectionMap[<span class="number">32</span>];                                                 <span class="comment">//0x0</span></span><br><span class="line">    UCHAR IoMap[<span class="number">8196</span>];                                                      <span class="comment">//0x20</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//0x20ac bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Backlink;                                                        <span class="comment">//0x0</span></span><br><span class="line">    USHORT Reserved0;                                                       <span class="comment">//0x2</span></span><br><span class="line">    ULONG Esp0;                                                             <span class="comment">//0x4</span></span><br><span class="line">    USHORT Ss0;                                                             <span class="comment">//0x8</span></span><br><span class="line">    USHORT Reserved1;                                                       <span class="comment">//0xa</span></span><br><span class="line">    ULONG NotUsed1[<span class="number">4</span>];                                                      <span class="comment">//0xc</span></span><br><span class="line">    ULONG CR3;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x24</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x30</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x34</span></span><br><span class="line">    ULONG Esp;                                                              <span class="comment">//0x38</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x44</span></span><br><span class="line">    USHORT Es;                                                              <span class="comment">//0x48</span></span><br><span class="line">    USHORT Reserved2;                                                       <span class="comment">//0x4a</span></span><br><span class="line">    USHORT Cs;                                                              <span class="comment">//0x4c</span></span><br><span class="line">    USHORT Reserved3;                                                       <span class="comment">//0x4e</span></span><br><span class="line">    USHORT Ss;                                                              <span class="comment">//0x50</span></span><br><span class="line">    USHORT Reserved4;                                                       <span class="comment">//0x52</span></span><br><span class="line">    USHORT Ds;                                                              <span class="comment">//0x54</span></span><br><span class="line">    USHORT Reserved5;                                                       <span class="comment">//0x56</span></span><br><span class="line">    USHORT Fs;                                                              <span class="comment">//0x58</span></span><br><span class="line">    USHORT Reserved6;                                                       <span class="comment">//0x5a</span></span><br><span class="line">    USHORT Gs;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    USHORT Reserved7;                                                       <span class="comment">//0x5e</span></span><br><span class="line">    USHORT LDT;                                                             <span class="comment">//0x60</span></span><br><span class="line">    USHORT Reserved8;                                                       <span class="comment">//0x62</span></span><br><span class="line">    USHORT Flags;                                                           <span class="comment">//0x64</span></span><br><span class="line">    USHORT IoMapBase;                                                       <span class="comment">//0x66</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span> <span class="title">IoMaps</span>[1];</span>                                        <span class="comment">//0x68</span></span><br><span class="line">    UCHAR IntDirectionMap[<span class="number">32</span>];                                              <span class="comment">//0x208c</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span> <span class="title">tss</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">		iretd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> esp3[<span class="number">0x2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> esp0[<span class="number">0x2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> trcode[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		str trcode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(esp3,<span class="number">0xCC</span>,<span class="number">0x2000</span>);<span class="comment">//挂物理页</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tss地址：%x\n&quot;</span>, &amp;tss);</span><br><span class="line">	tss.Eax = <span class="number">0</span>;</span><br><span class="line">	tss.Ecx = <span class="number">0</span>;</span><br><span class="line">	tss.Edx = <span class="number">0</span>;</span><br><span class="line">	tss.Ebx = <span class="number">0</span>;</span><br><span class="line">	tss.Ebp = <span class="number">0</span>;</span><br><span class="line">	tss.Esi = <span class="number">0</span>;</span><br><span class="line">	tss.Edi = <span class="number">0</span>;</span><br><span class="line">	tss.Cs = <span class="number">0x8</span>;</span><br><span class="line">	tss.Ss = <span class="number">0x10</span>;</span><br><span class="line">	tss.Ds = <span class="number">0x23</span>;</span><br><span class="line">	tss.Esp = (ULONG)(esp3+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Esp0 = (ULONG)(esp0+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Ss0 = <span class="number">0x10</span>;</span><br><span class="line">	tss.Fs = <span class="number">0x30</span>;</span><br><span class="line">	tss.Eip = (ULONG)a;</span><br><span class="line">	DWORD dwCr3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入CR3:&quot;</span>);</span><br><span class="line">	scanf_s(<span class="string">&quot;%x&quot;</span>, &amp;dwCr3);</span><br><span class="line">	tss.CR3 = dwCr3;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;CR3:%x&quot;</span>, tss.CR3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func:%x esp0:%x esp3:%x&quot;</span>, a, tss.Esp0, tss.Esp);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="comment">// printf(&quot;%x\n&quot;, sizeof(KTSS));</span></span><br><span class="line">	<span class="type">char</span> bufcode[<span class="number">6</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr bufcode;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，查看函数a的地址和程序的CR3。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031150810537.png" alt="image-20221031150810537"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031150905333.png" alt="image-20221031150905333"></p>
<p>构造TSS描述符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000E940`503020ab</span><br><span class="line"></span><br><span class="line">base:405030</span><br><span class="line">limit:0x20ab</span><br><span class="line">DPL：11 -&gt;3环可以访问到</span><br><span class="line">type:1001 -&gt; B = 0</span><br><span class="line">P:1</span><br><span class="line">G:0</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031151543103.png" alt="image-20221031151543103"></p>
<p>继续运行后发现windbg断下，然后使用uf查看汇编。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031152749546.png" alt="image-20221031152749546"></p>
<p>可以看到已经成功执行。此时输入<code>r tr</code>，发现索引已经为实验测试的0x48，使用dg解析。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031154025086.png" alt="image-20221031154025086"></p>
<p>可以看到Flags已经被设置为忙碌状态,9-&gt;b。使用dt重新查看tss结构。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155438210.png" alt="image-20221031155438210"></p>
<p>寄存器此时都为我们自定义的，但会发现此时的ESP并不为ESP0。。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155555167.png" alt="image-20221031155555167"></p>
<p>这是因为我们是构造了任务段，而不是通过r3切换到R0，当使用了中断门、调用门、陷阱门时才会进行切换。</p>
<p>输入g，继续运行，发现蓝屏。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031152833171.png" alt="image-20221031152833171"></p>
<h2 id="实验二：分析蓝屏原因"><a href="#实验二：分析蓝屏原因" class="headerlink" title="实验二：分析蓝屏原因"></a>实验二：分析蓝屏原因</h2><p>重新运行实验一的代码，并在call任务段的位置下断点。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031154909931.png" alt="image-20221031154909931"></p>
<p>重新运行，断下后转到反汇编。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155105966.png" alt="image-20221031155105966"></p>
<p>可以看到call后的返回地址为<code>0x4011cc</code>，然后继续运行后windbg断下，输入r tr查看获取TSS选择子后进行解析。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155314591.png" alt="image-20221031155314591"></p>
<p>查看原始TSS。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221031155342795.png" alt="image-20221031155342795"></p>
<p>会发现原始的TSS结构保存着真实的返回地址！！！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iretd:</span><br><span class="line">1)、NT如果为1，找到TSS的Previous Task Link，替换寄存器后返回(比如EIP)</span><br><span class="line">2)、如果NT为0，则从堆栈返回。（由于我们的堆栈在初始化时全是0xcccccc，因此返回到一个不存在的地址，就蓝屏了。）</span><br></pre></td></tr></table></figure>

<p>因此如果添加了int 3断点，则需要把eflags给恢复回来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span>;<span class="comment">//中断会清空Efl里的任务嵌套NT位，所以要修改回去</span></span><br><span class="line">        pushfd;</span><br><span class="line">        pop eax;</span><br><span class="line">        or eax, <span class="number">0x4000</span>;</span><br><span class="line">        push eax;</span><br><span class="line">        popfd;</span><br><span class="line">        iretd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="7、任务门"><a href="#7、任务门" class="headerlink" title="7、任务门"></a>7、任务门</h1><blockquote>
<p>关闭增量链接、关闭随即地址</p>
</blockquote>
<p>任务门结构图如下：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101213529497.png" alt="image-20221101213529497"></p>
<h2 id="Windows-双重异常"><a href="#Windows-双重异常" class="headerlink" title="Windows-双重异常"></a>Windows-双重异常</h2><p>Windows使用的任务门主要有作为<code>不可屏蔽中断</code>和<code>双重异常</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101204659991.png" alt="image-20221101204659991"></p>
<blockquote>
<p>双重异常：系统处理异常时触发的异常。Windows使用了任务门在实现双重异常是为了在触发双重异常时，可以将当前环境保存到TSS中，让开发者有信息进行调试、排查问题（系统无法解决双重异常，因此将触发时的环境保存在TSS中，然后反馈给开发者，让开发者自行解决）。</p>
</blockquote>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101213120017.png" alt="image-20221101213120017"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101213211284.png" alt="image-20221101213211284"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 0x8</span><br></pre></td></tr></table></figure>

<h2 id="实验一：构造任务门"><a href="#实验一：构造任务门" class="headerlink" title="实验一：构造任务门"></a>实验一：构造任务门</h2><p>选择0x48的位置来存放TSS。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101214425488.png" alt="image-20221101214425488"></p>
<p>构造任务门，写入idt+0x100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000e500`00480000</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101220518905.png" alt="image-20221101220518905"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x2024 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR DirectionMap[<span class="number">32</span>];                                                 <span class="comment">//0x0</span></span><br><span class="line">    UCHAR IoMap[<span class="number">8196</span>];                                                      <span class="comment">//0x20</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//0x20ac bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Backlink;                                                        <span class="comment">//0x0</span></span><br><span class="line">    USHORT Reserved0;                                                       <span class="comment">//0x2</span></span><br><span class="line">    ULONG Esp0;                                                             <span class="comment">//0x4</span></span><br><span class="line">    USHORT Ss0;                                                             <span class="comment">//0x8</span></span><br><span class="line">    USHORT Reserved1;                                                       <span class="comment">//0xa</span></span><br><span class="line">    ULONG NotUsed1[<span class="number">4</span>];                                                      <span class="comment">//0xc</span></span><br><span class="line">    ULONG CR3;                                                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Eip;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG EFlags;                                                           <span class="comment">//0x24</span></span><br><span class="line">    ULONG Eax;                                                              <span class="comment">//0x28</span></span><br><span class="line">    ULONG Ecx;                                                              <span class="comment">//0x2c</span></span><br><span class="line">    ULONG Edx;                                                              <span class="comment">//0x30</span></span><br><span class="line">    ULONG Ebx;                                                              <span class="comment">//0x34</span></span><br><span class="line">    ULONG Esp;                                                              <span class="comment">//0x38</span></span><br><span class="line">    ULONG Ebp;                                                              <span class="comment">//0x3c</span></span><br><span class="line">    ULONG Esi;                                                              <span class="comment">//0x40</span></span><br><span class="line">    ULONG Edi;                                                              <span class="comment">//0x44</span></span><br><span class="line">    USHORT Es;                                                              <span class="comment">//0x48</span></span><br><span class="line">    USHORT Reserved2;                                                       <span class="comment">//0x4a</span></span><br><span class="line">    USHORT Cs;                                                              <span class="comment">//0x4c</span></span><br><span class="line">    USHORT Reserved3;                                                       <span class="comment">//0x4e</span></span><br><span class="line">    USHORT Ss;                                                              <span class="comment">//0x50</span></span><br><span class="line">    USHORT Reserved4;                                                       <span class="comment">//0x52</span></span><br><span class="line">    USHORT Ds;                                                              <span class="comment">//0x54</span></span><br><span class="line">    USHORT Reserved5;                                                       <span class="comment">//0x56</span></span><br><span class="line">    USHORT Fs;                                                              <span class="comment">//0x58</span></span><br><span class="line">    USHORT Reserved6;                                                       <span class="comment">//0x5a</span></span><br><span class="line">    USHORT Gs;                                                              <span class="comment">//0x5c</span></span><br><span class="line">    USHORT Reserved7;                                                       <span class="comment">//0x5e</span></span><br><span class="line">    USHORT LDT;                                                             <span class="comment">//0x60</span></span><br><span class="line">    USHORT Reserved8;                                                       <span class="comment">//0x62</span></span><br><span class="line">    USHORT Flags;                                                           <span class="comment">//0x64</span></span><br><span class="line">    USHORT IoMapBase;                                                       <span class="comment">//0x66</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span> <span class="title">IoMaps</span>[1];</span>                                        <span class="comment">//0x68</span></span><br><span class="line">    UCHAR IntDirectionMap[<span class="number">32</span>];                                              <span class="comment">//0x208c</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span> <span class="title">tss</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span>;<span class="comment">//中断会清空Efl里的任务嵌套NT位，所以要修改回去</span></span><br><span class="line">        pushfd;</span><br><span class="line">        pop eax;</span><br><span class="line">        or eax, <span class="number">0x4000</span>;</span><br><span class="line">        push eax;</span><br><span class="line">        popfd;</span><br><span class="line">        iretd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> esp3[<span class="number">0x2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> esp0[<span class="number">0x2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> trcode[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		str trcode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(esp3,<span class="number">0xCC</span>,<span class="number">0x2000</span>);<span class="comment">//挂物理页</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tss地址：%x\n&quot;</span>, &amp;tss);</span><br><span class="line">	tss.Eax = <span class="number">0</span>;</span><br><span class="line">	tss.Ecx = <span class="number">0</span>;</span><br><span class="line">	tss.Edx = <span class="number">0</span>;</span><br><span class="line">	tss.Ebx = <span class="number">0</span>;</span><br><span class="line">	tss.Ebp = <span class="number">0</span>;</span><br><span class="line">	tss.Esi = <span class="number">0</span>;</span><br><span class="line">	tss.Edi = <span class="number">0</span>;</span><br><span class="line">	tss.Cs = <span class="number">0x8</span>;</span><br><span class="line">	tss.Ss = <span class="number">0x10</span>;</span><br><span class="line">	tss.Ds = <span class="number">0x23</span>;</span><br><span class="line">	tss.Esp = (ULONG)(esp3+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Esp0 = (ULONG)(esp0+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Ss0 = <span class="number">0x10</span>;</span><br><span class="line">	tss.Fs = <span class="number">0x30</span>;</span><br><span class="line">	tss.Eip = (ULONG)a;</span><br><span class="line">	DWORD dwCr3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入CR3:&quot;</span>);</span><br><span class="line">	scanf_s(<span class="string">&quot;%x&quot;</span>, &amp;dwCr3);</span><br><span class="line">	tss.CR3 = dwCr3;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;CR3:%x&quot;</span>, tss.CR3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func:%x esp0:%x esp3:%x&quot;</span>, a, tss.Esp0, tss.Esp);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="comment">// printf(&quot;%x\n&quot;, sizeof(KTSS));</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">        pushfd <span class="comment">//保存R3的FD</span></span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span> <span class="comment">//修改为中断，因为是从IDT中跳转</span></span><br><span class="line">        popfd</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造TSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000e940`50300068</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101221127844.png" alt="image-20221101221127844"></p>
<p>可以发现已经断下。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221101221219040.png" alt="image-20221101221219040"></p>
<p>输入g继续执行。</p>
<h1 id="8、101012分页"><a href="#8、101012分页" class="headerlink" title="8、101012分页"></a>8、101012分页</h1><p>Windows x86模式下有29912分页和101012分页，其中默认为29912分页。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102221050831.png" alt="image-20221102221050831"></p>
<h2 id="设置101012分页"><a href="#设置101012分页" class="headerlink" title="设置101012分页"></a>设置101012分页</h2><p>使用EasyBCD工具设置系统配置为如下：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102221555765.png" alt="image-20221102221555765"></p>
<p>重启即可。</p>
<h2 id="实验一：线性地址转物理地址"><a href="#实验一：线性地址转物理地址" class="headerlink" title="实验一：线性地址转物理地址"></a>实验一：线性地址转物理地址</h2><p>确保系统当前分页为101012模式！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> val[] =<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,val);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取变量val的逻辑地址。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102221412169.png" alt="image-20221102221412169"></p>
<p>然后将地址<code>0040312c</code>以101012格式拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0040312c</span><br><span class="line"></span><br><span class="line">0000 0000 0100 0000 0011 0001 0010 1100</span><br><span class="line"></span><br><span class="line">(不足的用0补充)</span><br><span class="line">0000 0000 0001(0x1) -&gt; PDT中PDE的索引号</span><br><span class="line">0000 0000 0011(0x3) -&gt; PTT中PTE的索引号</span><br><span class="line">0001 0010 1100(0x12c) -&gt; 页内偏移(物理页)</span><br></pre></td></tr></table></figure>

<p>使用windbg获取当前进程的CR3。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102222814542.png" alt="image-20221102222814542"></p>
<blockquote>
<p>小知识：如果!process 0 0遍历出来进程的CR3末尾三个数不为0，则说明是29912分页,如果为0则是101012分页。</p>
</blockquote>
<p>windbg中查看物理地址需要在命令前加上<code>!</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102222014984.png" alt="image-20221102222014984"></p>
<p>将刚刚拆分得到的数值进行与cr3计算。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102223147321.png" alt="image-20221102223147321"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102223314124.png" alt="image-20221102223314124"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102223456812.png" alt="image-20221102223456812"></p>
<p>最后一次计算不用*4是因为最后得到的<code>66c44000</code>是物理页，里边存放的是数据或者代码。前面两次 *4是因为要寻找PDE和PTE项。</p>
<hr>
<p><code>cr3:控制寄存器，里面存放页基址。一共有4096个字节的大小。</code></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102224139240.png" alt="image-20221102224139240"></p>
<blockquote>
<p>为什么一个页的大小为4096字节？原因是在29912或者101012中，后面的12位表示为页内偏移；当12为全部为1时，页内最大偏移为0xFFFF+1(加上偏移0)，也就是4096个字节。</p>
</blockquote>
<p>CPU拆分地址的操作由<code>模块MMU（Memory Manager Unit）</code>,相当于软件的函数。但因为每次寻址时都需要对线性地址拆分，因此操作系统使用了叫做<code>TLB缓存</code>的东西。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102232909532.png" alt="image-20221102232909532"></p>
<p>TLB中保存着线性地址(前20位)和物理页的对映关系,如果匹配到线性地址(前20位)就可以迅速找到物理页。</p>
<ul>
<li>当读数据时</li>
</ul>
<p>​	通过物理页与线性地址后12位的偏移组合得到最终的物理地址。</p>
<ul>
<li><p>当写数据时</p>
<p>为了避免一直访问物理页(内存条)，造成资源开销大，因此使用了L1、L2、L3缓存，也就是俗称的一级、二级、三级缓存。将数据写到缓存中，每隔一个时钟周期后才将缓存中的数据写到内存条上,这个操作叫做WB(写回绕，Write Back)<code>其中L1是所有CPU共享，L2、L3等是每个CPU都有一个</code>。</p>
</li>
</ul>
<p>如果在TLB中找不到线性地址和物理页的映射(TLB miss)，则会操作MMU模块将线性地址拆分后存入TLB缓存中。</p>
<hr>
<h2 id="实验二：将同一个线性地址转成物理地址"><a href="#实验二：将同一个线性地址转成物理地址" class="headerlink" title="实验二：将同一个线性地址转成物理地址"></a>实验二：将同一个线性地址转成物理地址</h2><blockquote>
<p>关闭随机地址。变量设置为全局或者静态。</p>
</blockquote>
<p>将实验一的程序编译后，同时运行两个。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102233427425.png" alt="image-20221102233427425"></p>
<p>可以看到线性地址一致，但CR3不同。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102234021660.png" alt="image-20221102234021660"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221102234105221.png" alt="image-20221102234105221"></p>
<p>可以看到两个线性地址虽然相同，但是对应的物理地址不同。可以得出结论，<code>同一个线性地址可以被映射为多个物理地址</code>。</p>
<h1 id="9、探索0地址"><a href="#9、探索0地址" class="headerlink" title="9、探索0地址"></a>9、探索0地址</h1><blockquote>
<p>关闭增量和随即地址。</p>
</blockquote>
<h2 id="实验一：0地址挂物理页"><a href="#实验一：0地址挂物理页" class="headerlink" title="实验一：0地址挂物理页"></a>实验一：0地址挂物理页</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;var);</span><br><span class="line">	<span class="type">int</span> * a = (<span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*a);</span><br><span class="line">    getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出var的地址，然后进行101012拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00405000</span><br><span class="line"></span><br><span class="line">0000 0000 0001(0x1)</span><br><span class="line">0000 0000 0101(0x5)</span><br><span class="line">0000 0000 0000(0x0)</span><br></pre></td></tr></table></figure>

<p>然后通过CR3寻找物理页。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215644361.png" alt="image-20221103215644361"></p>
<p>同样的方法，寻找0地址的物理页。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215710523.png" alt="image-20221103215710523"></p>
<p>发现0地址没有pte，将变量的pte挂上。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215741029.png" alt="image-20221103215741029"></p>
<p>继续运行程序。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103215939831.png" alt="image-20221103215939831"></p>
<h2 id="实验二：页内偏移对齐"><a href="#实验二：页内偏移对齐" class="headerlink" title="实验二：页内偏移对齐"></a>实验二：页内偏移对齐</h2><p>将实验一的全局变量改为局部变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;var);</span><br><span class="line">	<span class="type">int</span> * a = (<span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*a);</span><br><span class="line">    getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103220203339.png" alt="image-20221103220203339"></p>
<p>可以看到var的地址已经不是000结尾了，然后按照实验一的方法对0地址挂上pte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0012ff28</span><br><span class="line"></span><br><span class="line">0000 0000 0001 0010 1111 1111 0010 1000</span><br><span class="line"></span><br><span class="line">0000 0000 0000(0x0)</span><br><span class="line">0001 0010 1111(0x12F)</span><br><span class="line">1111 0010 1000(0xF28)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103220713373.png" alt="image-20221103220713373"></p>
<p>继续运行。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103220733841.png" alt="image-20221103220733841"></p>
<p>发现得到的内容不对。原因：变量var的页内偏移是0xf28，所以var的值为0x6b181000+0xf28的内容。但0地址拆分后得到的页内偏移也是0，读取到的数据是0x6b181000+0x0的内容。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103221310918.png" alt="image-20221103221310918"></p>
<p>如果要读到正确数据，需要将0地址的页内偏移变成0xF28。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;var);</span><br><span class="line">	<span class="type">int</span> offsets = (<span class="type">int</span>)&amp;var &amp; <span class="number">0xfff</span>;  <span class="comment">//取后三位</span></span><br><span class="line">	<span class="type">int</span> * a = (<span class="type">int</span> *)offsets;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*a);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103222041844.png" alt="image-20221103222041844"></p>
<h2 id="实验三：0地址实现shellcode执行"><a href="#实验三：0地址实现shellcode执行" class="headerlink" title="实验三：0地址实现shellcode执行"></a>实验三：0地址实现shellcode执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=&#123;</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0</span>,			<span class="comment">//push 0</span></span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0</span>,			<span class="comment">//push 0</span></span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0</span>,			<span class="comment">//push 0</span></span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0</span>,			<span class="comment">//push 0</span></span><br><span class="line">		<span class="number">0xb8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,	<span class="comment">//mov eax,0</span></span><br><span class="line">		<span class="number">0xff</span>,<span class="number">0xd0</span>,		<span class="comment">//call eax</span></span><br><span class="line">		<span class="number">0x83</span>,<span class="number">0xc4</span>,<span class="number">0x0c</span>,	<span class="comment">//add esp,c</span></span><br><span class="line">		<span class="number">0xc3</span>			<span class="comment">//ret</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fnMessageBoxA)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	*(<span class="type">int</span>*)&amp;shellcode[<span class="number">9</span>]=(<span class="type">int</span>)MessageBoxA;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,shellcode);</span><br><span class="line">	getchar();</span><br><span class="line">	fnMessageBoxA msgbox = (fnMessageBoxA)<span class="number">0</span>;</span><br><span class="line">	msgbox();</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出shellcode地址后拆分，将PTE赋值给0地址。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103224204506.png" alt="image-20221103224204506"></p>
<p>继续运行，弹出信息框。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103224240906.png" alt="image-20221103224240906"></p>
<hr>
<p>CPU的分页单位是4k，也就是一个页。</p>
<p>操作系统分页是64k。</p>
<p>当我们申请内存时，返回的其实是拥有64k大小的内存地址，并且如果只申请不用，还有可能并不会挂物理页。</p>
<p>当我们再次申请内存时，如果上一次申请的64k的页内存中有未使用的内存，则会返回内存对应的地址。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103225309298.png" alt="image-20221103225309298"></p>
<p>还有就是0x0-0x10000的地址为无权限，是操作系统为了保护访问异常数据时出错，是一种保护机制。比如int *p&#x3D;0,访问p时就会出错。另外r3和r0之前还有一块64k的空间也是无法使用的，这个区域隔离了用户和内核空间；防止用户程序跨越到内核空间中。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103230007148.png" alt="image-20221103230007148"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20221103232902036.png" alt="image-20221103232902036"></p>
<h1 id="10、页属性"><a href="#10、页属性" class="headerlink" title="10、页属性"></a>10、页属性</h1><p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412100130216.png" alt="image-20230412100130216"></p>
<p>P位：有效位，1为有效，0为无效。</p>
<p>R&#x2F;W：是否可读可写，0为可读，1为可读可写。</p>
<p>U&#x2F;S：实际上是R3&#x2F;R0，1为R3可访问；0为R3不可访问,R0可访问。</p>
<p>D：是否被写过，0为没有，1为被写入过。</p>
<p>A：是否被读过，0为没有，1为被读过。</p>
<p>PAT：是否存在下一个PTE，1为存在；0为不存在，如果为0则代表下一个是一个物理页。</p>
<p>G：是否为全局页，如果为1则表明TLB不进行刷新缓存（不绝对，只是有概率刷新）。</p>
<p>PS：物理页大小。为0则下一个页为4kb大小（小页），为1则下一个页为4mb大小（大页）。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412101456731.png" alt="image-20230412101456731"></p>
<h2 id="实验一：R-x2F-W位"><a href="#实验一：R-x2F-W位" class="headerlink" title="实验一：R&#x2F;W位"></a>实验一：R&#x2F;W位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* p=<span class="string">&quot;12345&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	p[<span class="number">0</span>]=<span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于字符串”12345”是一个常量，因此下边的修改行为存在异常。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412102152104.png" alt="image-20230412102152104"></p>
<p>使用CFF_Explorer查看.rdata区域的属性位0x40000040，为只读内存。表明系统在拉起该进程时为此段申请的内存属性为只读，因此无法进行修改。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412102229823.png" alt="image-20230412102229823"></p>
<p>将属性修改为0xC0000040后保存在运行。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412102406660.png" alt="image-20230412102406660"></p>
<p>运行成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">标志(属性块) 常用特征值对照表：</span><br><span class="line"></span><br><span class="line">[值:00000020h] [IMAGE_SCN_CNT_CODE                // Section contains code.(包含可执行代码)]</span><br><span class="line">[值:00000040h] [IMAGE_SCN_CNT_INITIALIZED_DATA    // Section contains initialized data.(该块包含已初始化的数据)]</span><br><span class="line">[值:00000080h] [IMAGE_SCN_CNT_UNINITIALIZED_DATA  // Section contains uninitialized data.(该块包含未初始化的数据)]</span><br><span class="line">[值:00000200h] [IMAGE_SCN_LNK_INFO                // Section contains comments or some other type of information.]</span><br><span class="line">[值:00000800h] [IMAGE_SCN_LNK_REMOVE              // Section contents will not become part of image.]</span><br><span class="line">[值:00001000h] [IMAGE_SCN_LNK_COMDAT              // Section contents comdat.]</span><br><span class="line">[值:00004000h] [IMAGE_SCN_NO_DEFER_SPEC_EXC       // Reset speculative exceptions handling bits in the TLB entries for this section.]</span><br><span class="line">[值:00008000h] [IMAGE_SCN_GPREL                   // Section content can be accessed relative to GP.]</span><br><span class="line">[值:00500000h] [IMAGE_SCN_ALIGN_16BYTES           // Default alignment if no others are specified.]</span><br><span class="line">[值:01000000h] [IMAGE_SCN_LNK_NRELOC_OVFL         // Section contains extended relocations.]</span><br><span class="line">[值:02000000h] [IMAGE_SCN_MEM_DISCARDABLE         // Section can be discarded.]</span><br><span class="line">[值:04000000h] [IMAGE_SCN_MEM_NOT_CACHED          // Section is not cachable.]</span><br><span class="line">[值:08000000h] [IMAGE_SCN_MEM_NOT_PAGED           // Section is not pageable.]</span><br><span class="line">[值:10000000h] [IMAGE_SCN_MEM_SHARED              // Section is shareable(该块为共享块).]</span><br><span class="line">[值:20000000h] [IMAGE_SCN_MEM_EXECUTE             // Section is executable.(该块可执行)]</span><br><span class="line">[值:40000000h] [IMAGE_SCN_MEM_READ                // Section is readable.(该块可读)]</span><br><span class="line">[值:80000000h] [IMAGE_SCN_MEM_WRITE               // Section is writeable.(该块可写)]</span><br></pre></td></tr></table></figure>

<p>重新运行程序，并使用windbg查看地址的pde&#x2F;pte。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412104327299.png" alt="image-20230412104327299"></p>
<p>PDE的属性为0x867-&gt; 1000 0110 0111，其中R&#x2F;W为1表明为可读可写，但是PTE的属性0x225-&gt; 0010 0010 0101，R&#x2F;W为0，表明为只读，将PTE的R&#x2F;W改为1.</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412104536369.png" alt="image-20230412104536369"></p>
<p>继续运行。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412104550249.png" alt="image-20230412104550249"></p>
<p>执行成功。</p>
<h2 id="实验二：U-x2F-W位"><a href="#实验二：U-x2F-W位" class="headerlink" title="实验二：U&#x2F;W位"></a>实验二：U&#x2F;W位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0x80b93800</span>; <span class="comment">//GDT</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	*(<span class="type">int</span>*)p=<span class="number">0x100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>R3中默认不可访问高位地址，因此代码运行时会异常。使用windbg查看GDT的页属性。由于高位地址在内存中共享，因此随意随意获取一个进程的CR3进行查看<code>!process 0 0 system</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412105907184.png" alt="image-20230412105907184"></p>
<p>PDE的页属性0x063-&gt;0000 0110 0011，U&#x2F;S为0表明只有R0可访问；PTE的页属性0x163-&gt;0001 0110 0011，U&#x2F;S为0表明只有R0可访问.将PDE和PTE的U&#x2F;S修改为1.</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412110130511.png" alt="image-20230412110130511"></p>
<p>运行。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230412110222330.png" alt="image-20230412110222330"></p>
<p>执行成功。</p>
<h1 id="11、页基址"><a href="#11、页基址" class="headerlink" title="11、页基址"></a>11、页基址</h1><p>操作系统启动流程：BIOS(实模式)-&gt;NtLdr(构建保护模式)-&gt;操作系统(管理内存)。</p>
<p>x86模式下，虚拟内存有4GB大小，其中高2G是内核共享，该2G中被划分为不同的部分，用来做不同的管理。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413094816983.png" alt="image-20230413094816983"></p>
<p>管理4GB大小的内存需要以下大小的空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（ 总大小 \ 页表大小 ）* 指针单位 = ( 4GB \ 4K ) * 4 = 4mb</span><br></pre></td></tr></table></figure>

<p>10-10-12模式下，有这样的指向 PDE-&gt;PTE-&gt;物理页;换句话来说，PTE由PDE管理,PDE由CR3管理。但由于这些都是物理地址，因此操作系统是怎么获取这些物理地址并管理的咧？</p>
<p>微软在管理内存时设计了一个特殊的基址0xC0000000，也就是页表基址。因为要管理4GB内存，因此页表基址的范围为0xC0000000~0xC0400000。这块区域中保存了系统中进程的PDE和PTE。</p>
<p>PDE保存的位置可以通过如下计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xC0000000 \ 4G * 4MB = 0xC0000000 \ 0x100000000 * 0x400000 = 0xC \ 0x10 * 0x400000 = 0xC * 0x40000 = 0x300000</span><br><span class="line"></span><br><span class="line">BASE_PDE = 0xC0000000 + 0x300000 = 0xC0300000</span><br></pre></td></tr></table></figure>

<p>而PTE则保存在0xC0000000~0xC02FFFFC。</p>
<p>所以对于所有PDE和PTE有如下公式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存的PTE = 0xC0000000 + PTI*4</span><br><span class="line">内存的PDE = 0xC0300000 + PDI*4</span><br></pre></td></tr></table></figure>

<p>PTI和PDI分别为虚拟地址的PTE和PDE的索引。</p>
<h2 id="实验一：验证页表基址"><a href="#实验一：验证页表基址" class="headerlink" title="实验一：验证页表基址"></a>实验一：验证页表基址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;x);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将输出的地址进行拆分0x0031f7c0</p>
<p>0000 0000 0000  0x0    </p>
<p>0011 0001 1111  0x31f</p>
<p>0111 1100 0000  0x7c0</p>
<p>然后获取对应的PDE和PTE</p>
<p>PDE&#x3D;0x4b96a867</p>
<p>PTE&#x3D;0x4b675867</p>
<p>使用页表基址获取PDE和PTE：</p>
<p>PDE&#x3D;0xC0300000+0x0&#x3D;0xC0300000</p>
<p>PTE&#x3D;0xC0000000+0x31f*4&#x3D;0xC0000C7C</p>
<p>切换进程环境读取这两个内存。(由于自写的程序为R3，无法访问高位地址。因此切换到system.exe进程，反正都是共享)。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413104410108.png" alt="image-20230413104410108"></p>
<p>可以看到是获取正确的。因此操作系统可以通过页表基址获取到所有内存的PTE和PDE，然后进行管理。</p>
<h2 id="实验二：页表基址获取自身CR3"><a href="#实验二：页表基址获取自身CR3" class="headerlink" title="实验二：页表基址获取自身CR3"></a>实验二：页表基址获取自身CR3</h2><p>微软有一个巧妙的设计，每一个PDE&#x2F;PTE的0xC00位置都指向了自身，这样既满足了页表基址的管理范围，又实现了通过构造特殊地址来获取自身的CR3。</p>
<p>将0xC00构造为一个地址0xC0000000，拆分后得到</p>
<p>0x300</p>
<p>0x0</p>
<p>0x0</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413105519620.png" alt="image-20230413105519620"></p>
<p>可以看到此时读取到的位置与CR3相同，由于10-10-12模式下拆3次读取是CPU的机制，因此可以构建这么一个地址0xC0300C00（地址范围在PDE范围内），拆分后如下：</p>
<p>0x300</p>
<p>0x300</p>
<p>0xc00</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413105722619.png" alt="image-20230413105722619"></p>
<p>就可以巧妙地得到了自身的CR3。正常读取该地址，效果也相同。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413105815776.png" alt="image-20230413105815776"></p>
<h2 id="实验三：逆向101012的MmIsAddressVaild"><a href="#实验三：逆向101012的MmIsAddressVaild" class="headerlink" title="实验三：逆向101012的MmIsAddressVaild"></a>实验三：逆向101012的MmIsAddressVaild</h2><p>对于10-10-12模式的内核程序为ntoskrnl.exe；2-9-9-12为ntoskrnlpa.exe。</p>
<p>进入函数<code>MmIsAddressValid</code>进行分析</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413113703728.png" alt="image-20230413113703728"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230413113807329.png" alt="image-20230413113807329"></p>
<blockquote>
<p>补充：后边学了29912后， &amp; 80实际上是判断PS位，101012分页下页大小为4kb(小页)，因此下边的cmp是判断如果ps&#x3D;1则返回false.</p>
</blockquote>
<h1 id="12、29912分页"><a href="#12、29912分页" class="headerlink" title="12、29912分页"></a>12、29912分页</h1><p>由于101012分页最大管理的内存为4G（2^10*2^10*2^12&#x3D;4GB）,在4GB无法满足后(迎接64时代)，Intel开始这设计了新的分页模式，既2-9-9-12，又称PAE（物理地址扩展）分页。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>页大小依旧为4kb，也就是2^12；既要能管理更多内存，又要向下兼容4GB内存管理，所以只能扩大地址总线长度为8，因此PTE和PDE的保存数量变成了4096 &#x2F; 8 &#x3D; 512（2^9），剩余的两位用于保存一个叫做PDEPTE（Page Directory Entry Page Table Entry，页目录页表入口）的索引。</p>
<h2 id="PDPTE"><a href="#PDPTE" class="headerlink" title="PDPTE"></a>PDPTE</h2><p>PDEPTE是新引入的项，总共有4个（2^2），且每个项占8字节。在29912下，CR3不再是直接指向PDE而是指向该表项。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519114908954.png" alt="image-20230519114908954"></p>
<p>0-12位为属性位。</p>
<ul>
<li>P位：有效位，0无效，1有效。</li>
<li>PWT：Page Write Through。直写，后边TLB会讲到。</li>
<li>PCD：Page Cache Disable。禁止写缓存，后边TLB会讲到。</li>
<li>Avail：操作系统用，CPU不用。</li>
</ul>
<h2 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h2><p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519151435985.png" alt="image-20230519151435985"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519151441972.png" alt="image-20230519151441972"></p>
<p>当PS&#x3D;1时是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。</p>
<p>2MB哪里来的呢？2-9-9-12，后面的9和12合并成了一个大页，所以是21位，也就是2的21次方，所以是2MB。</p>
<ul>
<li>PAT：Page Attribute Table，页属性表，当PDE的PS为0的时候就有没这一项，原因就是这个位是针对页的，目录当然没有。</li>
</ul>
<h3 id="XD-x2F-NX标志位"><a href="#XD-x2F-NX标志位" class="headerlink" title="XD&#x2F;NX标志位"></a>XD&#x2F;NX标志位</h3><p>该位也叫做（DEP数据执行保护），在PAE分页模式下，PDE与PTE的最高位为XD&#x2F;NX位。<strong>Intel</strong>中称为XD，<strong>AMD</strong>中称为NX，即No Excetion。<br>段的属性有可读、可写和可执行，页的属性有可读、可写。当RET执行返回的时候，如果<strong>把堆栈里面的数据指向一段提前准备好的数据</strong>（把数据当作代码来执行，漏洞都是依赖这点，比如SQL注入也是），那么就会产生<strong>任意代码执行</strong>的后果所以，Intel就在这方面做了硬件保护，设置了一个<strong>不可执行位 – XD&#x2F;NX位</strong>。当XD&#x3D;1时，软件产生了溢出也没有关系，即使EIP蹦到了危险的“数据区”，也是不可以执行的</p>
<h2 id="实验一：手动寻找物理地址"><a href="#实验一：手动寻找物理地址" class="headerlink" title="实验一：手动寻找物理地址"></a>实验一：手动寻找物理地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> test[]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,test);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,test);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,test);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将输出的地址进行划分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x001FF978</span><br><span class="line">0000 0000 0000    0*8</span><br><span class="line">0000 0000 0000    0*8</span><br><span class="line">0001 1111 1111    1ff*8</span><br><span class="line">1001 0111 1000    978</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519121927102.png" alt="image-20230519121927102"></p>
<p>尝试修改字符串。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519121953464.png" alt="image-20230519121953464"></p>
<p>回到R3，再次输出。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519122028569.png" alt="image-20230519122028569"></p>
<p>内容已改变<code>这里其实是改错了，应该用的是eb，这里用了ed，所以输出了e</code>。</p>
<blockquote>
<p>这里也可以看到最后找到的PTE地址头部为8，即1000，地址最高位为1，表明当前XD&#x3D;1，数据为不可执行。</p>
</blockquote>
<h2 id="实验二：逆向29912的MmIsAddressVaild"><a href="#实验二：逆向29912的MmIsAddressVaild" class="headerlink" title="实验二：逆向29912的MmIsAddressVaild"></a>实验二：逆向29912的MmIsAddressVaild</h2><p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521012611661.png" alt="image-20230521012611661"></p>
<blockquote>
<p>总结：如果PDE为大页则直接返回true，否则常规检查PTE。</p>
</blockquote>
<hr>
<p>额外指令学习：</p>
<ul>
<li>x：搜索导入表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; x nt!*IsAddress*</span><br><span class="line">84008ea2          nt!PopIsAddressRangeValid (@PopIsAddressRangeValid@8)</span><br><span class="line">84008ea2          nt!IopIsAddressRangeValid (_IopIsAddressRangeValid@8)</span><br><span class="line">840913c8          nt!MiIsAddressValid (_MiIsAddressValid@8)</span><br><span class="line">8400df4c          nt!MmIsAddressValid (_MmIsAddressValid@4)</span><br><span class="line"></span><br><span class="line">*代表模糊匹配</span><br></pre></td></tr></table></figure>

<ul>
<li>!pte：显示虚拟地址的PTE和PDE基地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pte 84008ea2</span><br><span class="line">                 VA 84008ea2</span><br><span class="line">PDE at C0300840         PTE at C0210020</span><br><span class="line">contains 001C3063       contains 04008121</span><br><span class="line">pfn 1c3   ---DA--KWEV   pfn 4008  -G--A--KREV</span><br></pre></td></tr></table></figure>

<h1 id="13、PAT-PCD-PWT"><a href="#13、PAT-PCD-PWT" class="headerlink" title="13、PAT\PCD\PWT"></a>13、PAT\PCD\PWT</h1><h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>CPU缓存是介于CPU和物理内存之间的临时存储器。它容量比内存小得多，但读写速度比内存要快得多。越强大的CPU，CPU缓存大小越大。与TLB不同，TLB是线性地址和物理地址间的映射缓存。 而CPU缓存是物理地址和地址内的数值（内容）间的映射缓存。TLB+CPU缓存搭配可以大大加快读取速度。CPU读写内存时，会先去CPU缓存中寻找该物理地址，如果缓存中存在该物理地址，则读写全部对CPU缓存操作。</p>
<p>CPU缓存分为3级，<code>L1</code>,<code>L2</code>,<code>L3</code>。</p>
<p>L1缓存速度最快，容量最小，<code>一个核一个</code>。</p>
<p>L2缓存比L1容量大，速度略慢。<code>一个核一个</code>。</p>
<p>L3缓存比L2容量大，速度最慢。<code>所有核共享一个</code>。</p>
<p>在读写内存时，会依次从L1-&gt;L2-&gt;L3进行查找。若在L2中找到了，会将缓存更新到L1（提升下次访问速度）。若在L3中找到了，会将缓存更新到L1 L2。所以L1一直都在变。</p>
<h2 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h2><p>Intel<code>定义</code>了如下类型；</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524231314576.png" alt="image-20230524231314576"></p>
<ul>
<li>UC：无缓存</li>
<li>WC：组合写（直写+回写），写入缓存，什么时候写入物理内存，由CPU决定。</li>
<li>WT：直写，即写到物理内存也写入缓存。</li>
<li>WP：写保护，置1后写内存直接异常。<code>这里的写保护是局部，而CR4中的WP为全局</code></li>
<li>WB：回写，先写入缓存，过一段时间再写入物理内存。</li>
<li>UC-：-号代表弱，表示有时候会有缓存，有时候没有。</li>
</ul>
<p>一块内存的缓存类型可以通过PAT-PCD-PWT进行组合判断。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524233000843.png" alt="image-20230524233000843"></p>
<h2 id="MSR寄存器"><a href="#MSR寄存器" class="headerlink" title="MSR寄存器"></a>MSR寄存器</h2><blockquote>
<p>MSR中保存着对PAT属性的定义。可以自己自定义</p>
</blockquote>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524233239514.png" alt="image-20230524233239514"></p>
<p>windbg使用<code>rdmsr addr</code>来查看保存的值。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230524233420397.png" alt="image-20230524233420397"></p>
<p>拆分后得到如下：</p>
<table>
<thead>
<tr>
<th>PAT7</th>
<th>PAT6</th>
<th>PAT5</th>
<th>PAT4</th>
<th>PAT3</th>
<th>PAT2</th>
<th>PAT1</th>
<th>PAT0</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>07</td>
<td>01</td>
<td>06</td>
<td>00</td>
<td>07</td>
<td>01</td>
<td>06</td>
</tr>
</tbody></table>
<p>当PAT&#x3D;0，PCD&#x3D;0,PWT&#x3D;0，查右边第0个，也就是PAT*，得到6。6对应到上边的<code>Table 11.10</code>就是WB。</p>
<h1 id="14、TLB"><a href="#14、TLB" class="headerlink" title="14、TLB"></a>14、TLB</h1><p>TLB（Translation Lookaside Buffer，转换后备缓冲区），tlb保存的是一种&lt;线性地址,物理地址&gt;的映射关系，系统每次在读取地址数据时如果都需要进行拆分，那么带来的消耗巨大，因此Intel设计了一种缓存的形式来缓解开销。当我们读取某个地址时，CPU会首先查询这一块表是否存在映射关系，如果不存在则进行拆分后读取数据并返回，然后将线性地址与物理地址的映射关系保存到TLB表中，如果下一次在读取该地址，则会在TLB中查询对应的物理地址。极大的提高了效率。<code>数据和代码指令各有有自己的TLB</code>。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/QQ%E5%9B%BE%E7%89%8720230519152651.png" alt="QQ图片20230519152651"></p>
<ul>
<li><p>LA：线性地址</p>
</li>
<li><p>PA：物理地址</p>
</li>
<li><p>ATTR：在10-10-12分页模式下：ATTR &#x3D; PDE属性 &amp; PTE属性。在2-9-9-12分页模式下：ATTR &#x3D; PDPTE属性 &amp; PDE属性 &amp; PTE属性</p>
</li>
<li><p>LRU：统计信息。由于TLB的大小有限，因此当TLB被写满、又有新的地址即将写入时，TLB就会根据统计信息来判断哪些地址是不常用的，从而将不常用的记录从TLB中移除。</p>
</li>
</ul>
<p>需要注意的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不同的CPU，TLB大小不同。只要Cr3发生变化，TLB立即刷新，一核一套TLB</span><br><span class="line">由于操作系统的高2G映射基本不变，因此如果Cr3改了，TLB刷新的话，重建高2G以上很浪费。</span><br><span class="line">所以PDE和PTE中有个G标志位（当PDE为大页时，G标志位才起作用），如果G位为1，刷新TLB时将不会刷新PDE/PTE</span><br><span class="line">G位为1的页，当TLB写满时，CPU根据统计信息将不常用的地址废弃，保留最常用的地址</span><br></pre></td></tr></table></figure>

<p>TLB也分有下列种类：</p>
<ul>
<li>物理页分为普通页（4KB）、大页（2MB&#x2F;4MB），物理页又分为指令和数据。因此分为4种TLB</li>
<li>缓存一般页表（4KB）的指令页表缓存（Instruction-TLB）</li>
<li>缓存一般页表（4KB）的数据页表缓存（Data-TLB）</li>
<li>缓存大尺寸页表（2MB&#x2F;4MB）的指令页表缓存（Instruction-TLB）</li>
<li>缓存大尺寸页表（2MB&#x2F;4MB）的数据页表缓存（Data-TLB）</li>
</ul>
<p>查找流程：</p>
<p>1、线性地址–&gt;TLB缓存</p>
<p>2、没有找到  则  线性地址–&gt;物理帧缓存（page struct cache）–&gt;PDE页帧–&gt;PTE页帧（PTE并没有被缓存<br>保存。</p>
<p>3、都没有则  线性地址–&gt;PDPTE–&gt;PDE-&gt;PTE。</p>
<h2 id="INVLPG指令"><a href="#INVLPG指令" class="headerlink" title="INVLPG指令"></a>INVLPG指令</h2><p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519154133640.png" alt="image-20230519154133640"></p>
<p>简单说该指令用于删除某线性地址在TLB中的记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invlpg dword ps:[0] ;删除0地址在tlb中的缓存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下实验均为101012分页</p>
</blockquote>
<h2 id="实验一：CR3刷新TLB"><a href="#实验一：CR3刷新TLB" class="headerlink" title="实验一：CR3刷新TLB"></a>实验一：CR3刷新TLB</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">PageOnNull</span>() &#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存现场</span></span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		sub esp, <span class="number">0x100</span></span><br><span class="line">		push ebx</span><br><span class="line">		push esi</span><br><span class="line">		push edi</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD* pPTE;			<span class="comment">// 保存目标线性地址的 PTE 线性地址</span></span><br><span class="line">	DWORD* pNullPTE;		<span class="comment">// 0 地址的 PTE 线性地址</span></span><br><span class="line">	pNullPTE = (DWORD*)<span class="number">0xC0000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x50000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x50000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	x = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x60000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x60000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	y = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新 TLB </span></span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov eax, cr3</span><br><span class="line">		mov cr3, eax</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次读取 0 地址位置的数据</span></span><br><span class="line">	z = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复现场</span></span><br><span class="line">		pop edi</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		mov esp, ebp</span><br><span class="line">		pop ebp</span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD* p5 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x50000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	DWORD* p6 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x60000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (p5 != (DWORD*)<span class="number">0x50000000</span> || p6 != (DWORD*)<span class="number">0x60000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error alloc!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*p5 = <span class="number">0x1234</span>;</span><br><span class="line">	*p6 = <span class="number">0x5678</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过中断门提权</span></span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1. 读 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2. 给 0 地址重新挂上物理页\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3. 重新读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4. 刷新 TLB \n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5. 再次读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n&quot;</span>, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519160245941.png" alt="image-20230519160245941"></p>
<p>设计中断门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">offset: 0x001213c0</span><br><span class="line">P:1</span><br><span class="line">DPL:3</span><br><span class="line">TYPE:0xE</span><br><span class="line">Selector:1000</span><br><span class="line"></span><br><span class="line">0012ee00`000813c0</span><br></pre></td></tr></table></figure>

<p>写入描述符。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519161304372.png" alt="image-20230519161304372"></p>
<p>运行效果</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519161452057.png" alt="image-20230519161452057"></p>
<p>可以发现，在x被赋值完成后，即使0地址被挂上了新的物理页，再对y进行赋值，x和y输出的值是相同的。但是在Cr3刷新后，0地址没有被挂上新的物理页，对z进行赋值后，z却输出了新的值。这是因为Cr3刷新前，0地址第一次被x访问时，线性地址与物理地址的对应关系被写入了TLB中，因此在对y赋值时，TLB的记录没有被刷新，访问的还是原来的物理页。</p>
<h2 id="实验二：修改pte的G位禁止刷新TLB"><a href="#实验二：修改pte的G位禁止刷新TLB" class="headerlink" title="实验二：修改pte的G位禁止刷新TLB"></a>实验二：修改pte的G位禁止刷新TLB</h2><p>由于需要给G位置1，因此这里使用windbg进行辅助。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">PageOnNull</span>() &#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存现场</span></span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		sub esp, <span class="number">0x100</span></span><br><span class="line">		push ebx</span><br><span class="line">		push esi</span><br><span class="line">		push edi</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD* pPTE;			<span class="comment">// 保存目标线性地址的 PTE 线性地址</span></span><br><span class="line">	DWORD* pNullPTE;		<span class="comment">// 0 地址的 PTE 线性地址</span></span><br><span class="line">	pNullPTE = (DWORD*)<span class="number">0xC0000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x50000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x50000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line">	<span class="comment">//修改G位为1</span></span><br><span class="line">	*pNullPTE = *pNullPTE | <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">	x = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x60000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x60000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	y = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新 TLB </span></span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov eax, cr3</span><br><span class="line">		mov cr3, eax</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次读取 0 地址位置的数据</span></span><br><span class="line">	z = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复现场</span></span><br><span class="line">		pop edi</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		mov esp, ebp</span><br><span class="line">		pop ebp</span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD* p5 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x50000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	DWORD* p6 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x60000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (p5 != (DWORD*)<span class="number">0x50000000</span> || p6 != (DWORD*)<span class="number">0x60000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error alloc!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	*p5 = <span class="number">0x1234</span>;</span><br><span class="line">	*p6 = <span class="number">0x5678</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过中断门提权</span></span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1. 给0x50000000的PTE的G位赋值为1\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2. 挂载并读 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3. 给 0 地址重新挂上物理页\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4. 重新读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5. 刷新 TLB \n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;6. 再次读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n&quot;</span>, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果。</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230519164716376.png" alt="image-20230519164716376"></p>
<p>实验结果证明G&#x3D;1时，TLB不刷新。</p>
<h2 id="实验三：INVLPG刷新TLB"><a href="#实验三：INVLPG刷新TLB" class="headerlink" title="实验三：INVLPG刷新TLB"></a>实验三：INVLPG刷新TLB</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">PageOnNull</span>() &#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存现场</span></span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		sub esp, <span class="number">0x100</span></span><br><span class="line">		push ebx</span><br><span class="line">		push esi</span><br><span class="line">		push edi</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD* pPTE;			<span class="comment">// 保存目标线性地址的 PTE 线性地址</span></span><br><span class="line">	DWORD* pNullPTE;		<span class="comment">// 0 地址的 PTE 线性地址</span></span><br><span class="line">	pNullPTE = (DWORD*)<span class="number">0xC0000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x50000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x50000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	x = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x60000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x60000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	y = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新 TLB </span></span><br><span class="line">	__asm&#123;</span><br><span class="line">	</span><br><span class="line">	invlpg dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次读取 0 地址位置的数据</span></span><br><span class="line">	z = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复现场</span></span><br><span class="line">		pop edi</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		mov esp, ebp</span><br><span class="line">		pop ebp</span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD* p5 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x50000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	DWORD* p6 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x60000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (p5 != (DWORD*)<span class="number">0x50000000</span> || p6 != (DWORD*)<span class="number">0x60000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error alloc!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*p5 = <span class="number">0x1234</span>;</span><br><span class="line">	*p6 = <span class="number">0x5678</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过中断门提权</span></span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1. 读 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2. 给 0 地址重新挂上物理页\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3. 重新读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4. 刷新 TLB \n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5. 再次读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n&quot;</span>, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521142724659.png" alt="image-20230521142724659"></p>
<h2 id="实验四：CR4刷新TLB"><a href="#实验四：CR4刷新TLB" class="headerlink" title="实验四：CR4刷新TLB"></a>实验四：CR4刷新TLB</h2><p>CR4中第八位PGE位</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521143220842.png" alt="image-20230521143220842"></p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521143513360.png" alt="image-20230521143513360"></p>
<p>由于VS不支持CR4，因此使用硬编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">009D126E | 0F20E0                   | mov eax,cr4                                               |</span><br><span class="line">009D1271 | 0F22E0                   | mov cr4,eax                                               |</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">PageOnNull</span>() &#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存现场</span></span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		sub esp, <span class="number">0x100</span></span><br><span class="line">		push ebx</span><br><span class="line">		push esi</span><br><span class="line">		push edi</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD* pPTE;			<span class="comment">// 保存目标线性地址的 PTE 线性地址</span></span><br><span class="line">	DWORD* pNullPTE;		<span class="comment">// 0 地址的 PTE 线性地址</span></span><br><span class="line">	pNullPTE = (DWORD*)<span class="number">0xC0000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x50000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x50000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	x = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂上 0x60000000 所在位置</span></span><br><span class="line">	pPTE = (DWORD*)(<span class="number">0xC0000000</span> + (<span class="number">0x60000000</span> &gt;&gt; <span class="number">10</span>));	</span><br><span class="line">	*pNullPTE = *pPTE;</span><br><span class="line"></span><br><span class="line">	y = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 刷新 TLB </span></span><br><span class="line">	__asm&#123;</span><br><span class="line">	<span class="comment">//mov eax,cr4</span></span><br><span class="line">	__emit <span class="number">0x0F</span>;</span><br><span class="line">	__emit <span class="number">0x20</span>;</span><br><span class="line">	__emit <span class="number">0xe0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mov ebx,<span class="number">0x80</span>;</span><br><span class="line">	<span class="keyword">not</span> ebx;</span><br><span class="line">	<span class="keyword">and</span> eax,ebx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//mov cr4,eax</span></span><br><span class="line">	__emit <span class="number">0x0F</span>;</span><br><span class="line">	__emit <span class="number">0x22</span>;</span><br><span class="line">	__emit <span class="number">0xe0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次读取 0 地址位置的数据</span></span><br><span class="line">	z = *(DWORD*)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复现场</span></span><br><span class="line">		pop edi</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		mov esp, ebp</span><br><span class="line">		pop ebp</span><br><span class="line">		iretd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD* p5 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x50000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	DWORD* p6 = (DWORD*)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x60000000</span>, <span class="number">4</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (p5 != (DWORD*)<span class="number">0x50000000</span> || p6 != (DWORD*)<span class="number">0x60000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error alloc!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*p5 = <span class="number">0x1234</span>;</span><br><span class="line">	*p6 = <span class="number">0x5678</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过中断门提权</span></span><br><span class="line">		<span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1. 读 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2. 给 0 地址重新挂上物理页\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3. 重新读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n\n&quot;</span>, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4. 刷新 TLB \n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5. 再次读取 0 地址数据:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*NULL = 0x%x \n&quot;</span>, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521144553724.png" alt="image-20230521144553724"></p>
<h1 id="15、控制寄存器"><a href="#15、控制寄存器" class="headerlink" title="15、控制寄存器"></a>15、控制寄存器</h1><p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521143220842.png" alt="image-20230521143220842"></p>
<blockquote>
<p>注意： 控制寄存器中有些位一旦置1，则代表对应功能直接启用。 有些位只有置1了，对应功能才可以被启用，具体启不启用看细化到PTE之类上面的控制位。 所以学习控制寄存器属性时需要留意。</p>
</blockquote>
<p><code>CR1、CR5、CR6 操作系统不用</code></p>
<h2 id="Cr0（全局控制器）"><a href="#Cr0（全局控制器）" class="headerlink" title="Cr0（全局控制器）"></a>Cr0（全局控制器）</h2><ul>
<li>PE</li>
</ul>
<p><code>Protection Enabled</code>：保护启用位，为1时是保护模式 ，为0时是实模式。 1时仅启用段保护机制。</p>
<ul>
<li>PG</li>
</ul>
<p><code>Paging</code>：页保护启用位（分页机制位），为1时代表启用分页保护机制。 为0时不启用分页保护机制（线性地址&#x3D;物理地址）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PE=0 PG=0  处理器工作在实模式下 （由于实模式无法使用，因此CPU提供了一个虚拟8086模式，也叫虚拟实模式）PE=1  PG=0  处理器工作在保护模式下，但只有段机制的保护，没有页机制的保护PE=0  PG=1  处理器工作在实模式下。 由于PE为0，所以PG位即使为1也不会开启页保护。同时会触发一个 一般保护异常（GP：General-protection exception）。PE=1 PG=1  处理器工作在保护模式下，同时开启了段机制保护与页机制保护。</span><br></pre></td></tr></table></figure>

<ul>
<li>WP</li>
</ul>
<p><code>Write Protect</code>：写保护位，当WP为1时，超级特权用户（0环）不可以向用户层只读地址写入数据。x86下置1可直接修改所有只读数据，x64引入VT后，修改CR0操作可能会被拦截且触发蓝屏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPL&lt;3时，此时为特权层，用户层地址A（US=1）对应的页为只读页。当WP为0时，特权层程序可以对地址A进行写的操作。当WP为1时，特权层程序无法对地址A进行写的操作。</span><br></pre></td></tr></table></figure>

<ul>
<li>MP EM ET NE NW</li>
</ul>
<p>与数学运算相关，不用了解。</p>
<ul>
<li>TS</li>
</ul>
<p><code>Task Switched</code>: 任务切换位。当call入任务门时，TS位置1。当从任务门中返回时，TS位置0。</p>
<ul>
<li>CD</li>
</ul>
<p><code>Cache Disable</code> ： 缓存禁用位。 当置1时，所有缓存全部禁用。相当于缓存的总开关。</p>
<ul>
<li>AM</li>
</ul>
<p><code>Alignment Mask</code>：对齐位。为1时，启用对齐检查。为0时，关闭对齐检查。</p>
<h2 id="Cr1（保留）"><a href="#Cr1（保留）" class="headerlink" title="Cr1（保留）"></a>Cr1（保留）</h2><p>Cr1寄存器在X86架构中为保留状态，并未使用。</p>
<h2 id="Cr2（缺页异常地址）"><a href="#Cr2（缺页异常地址）" class="headerlink" title="Cr2（缺页异常地址）"></a>Cr2（缺页异常地址）</h2><p>当程序执行发生缺页异常时（E号中断），CPU会将触发了缺页异常的线性地址写入Cr2寄存器。供异常处理函数（E号中断）使用。</p>
<p>如 00401000:mov eax,[12345678]，若12345678地址无效，则CR2中存12345678. 若401000地址无效，则CR2存00401000.</p>
<h2 id="Cr3（PDBR）"><a href="#Cr3（PDBR）" class="headerlink" title="Cr3（PDBR）"></a>Cr3（PDBR）</h2><p>页目录表基址。</p>
<ul>
<li>PCD：PageLevelCacheDisabled，缓存禁用位。 为1时，禁用页表缓存。该位仅在CR0.PG&#x3D;1且CR0.CD&#x3D;0时才有效果。</li>
</ul>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521160606649.png" alt="image-20230521160606649"></p>
<ul>
<li>PWT：PageLevelWriteThrough，页直写位。 为1时，页表使用直写缓存，为0时页表使用回写缓存。</li>
</ul>
<p><img src="/../images/Window-Kernel/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20230521160642513.png" alt="image-20230521160642513"></p>
<p>PCD和PWT不同来源的不同影响:</p>
<p>当访问一个32位分页模式（101012）下的PDE时，PCD与PWT取自CR3寄存器。</p>
<p>当访问一个PAE模式（29912）下的PDE时，PCD与PWT取自PDPTE相关寄存器</p>
<p>当访问一个PTE时，PCD与PWT取自对应的PDE。</p>
<p>当访问一个从线性地址翻译过来的物理地址时，PCD与PWT取自与PTE或PDE。</p>
<h2 id="Cr4（个性化控制器）"><a href="#Cr4（个性化控制器）" class="headerlink" title="Cr4（个性化控制器）"></a>Cr4（个性化控制器）</h2><ul>
<li><p>VME：<code>Virtual-8086 Mode Extensions，虚拟8086模式扩展位</code>。置1时，启用虚拟8086模式的中断和异常处理。置0时，不启用。</p>
</li>
<li><p>PVI：<code>Protected-mode Virtual Interrupts,虚拟8086中断位</code>。置1时，启用VIF（virtual interrupt flag）位。置0时，VIF位无效。</p>
</li>
<li><p>TSD：<code>Time Stamp Disable,时间戳禁用位</code>。置1时，只有特权级用户才可以执行RDTSC指令。置0时，所有用户都可以执行RDTSC指令。 该指令用于获取Tick值。</p>
</li>
<li><p>DE：<code>Debugging Extensions,调试扩展位</code>。置1时，调试寄存器DR4 DR5启用。置0时，DR4 DR5保留。DR4 DR5启用时作为DR6 DR7使用。</p>
</li>
<li><p>PSE：<code>Page Size Extensions,页尺寸扩展位</code>。置1时，PDE的PS位才有效果。置0时，PDE的PS位作废。</p>
</li>
<li><p>PAE：<code>Physical Address Extensions,物理地址扩展位</code>。 为1时，29912分页。为0时，101012分页。</p>
</li>
<li><p>MCE：<code>Machine-Check Enable,机器检查启用位</code>。置1时，会检查硬件连接。置0时，不会检查硬件连接。</p>
</li>
<li><p>PGE：<code>Page Global Enable,全局页启用位</code>。置1时，PDE PTE的G位才有效果。否则无效果；0时会刷新TLB。</p>
</li>
<li><p>PCE：<code>Performance-Monitoring Counter Enable,性能监控计数器启用位</code>。置1时，3环可以执行RDPMC指令。否则只能在特权级执行。</p>
</li>
<li><p>VMXE：<code>VMX-Enable,VT标志位</code>。为1时，代表处于VT模式下。为0时，未处于VT模式。特权级为-1</p>
</li>
<li><p>SMXE：<code>SMX-Enable,更安全模式位（Safer-mode）</code>。为1时，处于SM模式下。否则未处于。特权级为-2</p>
</li>
<li><p>SMEP和SMAP：<code>SuperModeExecuteProtect,特权执行保护</code>。为1时，特权级不能执行US&#x3D;1的代码。<code>SuperModeAccessProtect,特权访问保护</code>。为1时，特权级不能访问US&#x3D;1的数据。</p>
</li>
</ul>
<blockquote>
<p>在64位中，CR0.AM不再作为扩展位存在，而是控制SMEP与SMAP。当AM&#x3D;0时，SMEP和SMAP失效。</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2023/01/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90VAC/" rel="next" title="从零开始分析VAC">
                  从零开始分析VAC <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlaneJun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
